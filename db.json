{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/Yelee/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-1.jpg","path":"background/bg-1.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-2.jpg","path":"background/bg-2.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-5.jpg","path":"background/bg-5.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-3.jpg","path":"background/bg-3.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-4.jpg","path":"background/bg-4.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-7.jpg","path":"background/bg-7.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-6.jpg","path":"background/bg-6.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/js/instagram.js","path":"js/instagram.js","modified":0,"renderable":1},{"_id":"themes/Yelee/source/js/GithubRepoWidget.js","path":"js/GithubRepoWidget.js","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-8.jpg","path":"background/bg-8.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/Yelee/source/js/pc.js","path":"js/pc.js","modified":0,"renderable":1},{"_id":"themes/Yelee/source/js/mobile.js","path":"js/mobile.js","modified":0,"renderable":1},{"_id":"themes/Yelee/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/Plunker.png","path":"img/Plunker.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/CSDN.png","path":"img/CSDN.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/TiddlyWiki.png","path":"img/TiddlyWiki.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/SegmentFault.png","path":"img/SegmentFault.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/V2EX.png","path":"img/V2EX.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/简书.png","path":"img/简书.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/知乎.png","path":"img/知乎.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/新浪微博.png","path":"img/新浪微博.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/博客园.png","path":"img/博客园.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/豆瓣.png","path":"img/豆瓣.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/虾米音乐.png","path":"img/虾米音乐.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/网易云音乐.png","path":"img/网易云音乐.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/BO7190VR00BV0005.jpg","path":"img/BO7190VR00BV0005.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-10.jpg","path":"background/bg-10.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-9.jpg","path":"background/bg-9.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/123.md","hash":"f5b36f40999de4e2bbfcb019abd83dcc077ed166","modified":1464590166000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1464587573000},{"_id":"source/_posts/hello-world.md","hash":"13b892a3ce8ae8e095792c05b2acba681aeec1da","modified":1464590328000},{"_id":"source/_posts/hello-world副本.md","hash":"2b9db5c7cbce72664f137fca9da2c0d73cc6a736","modified":1464589902000},{"_id":"source/_posts/开发利器-Block.md","hash":"df187e35078b9cd758bac86782f4280831a873aa","modified":1464589518000},{"_id":"source/tags/index.md","hash":"b8698b96872196c1d30d7776c0c15221961e315d","modified":1464548765000},{"_id":"source/tags/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1464587605000},{"_id":"source/about/index.md","hash":"eaa15cd3aee83cad7b8ae4f52cc57875eaf3cdce","modified":1464587584000},{"_id":"themes/Yelee/_config.yml","hash":"cd0c8a089d53eb64cd5e8518aad8035b7df538d3","modified":1464589238000},{"_id":"themes/Yelee/.gitignore","hash":"237760b38ce80bcc3a8b556566bef0295c145393","modified":1464546904000},{"_id":"themes/Yelee/README.md","hash":"f818502733e5c4de72266e43a910a0f3f862e490","modified":1464546904000},{"_id":"themes/Yelee/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1464546905000},{"_id":"source/categories/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1464587599000},{"_id":"source/categories/index.md","hash":"a86f30c5e75c852d4805d3fc67a1abd68bab22a4","modified":1464548720000},{"_id":"themes/Yelee/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1464546904000},{"_id":"themes/Yelee/.git/config","hash":"900873b633dea689f1f85eb22fdcad2ff83c0a23","modified":1464546904000},{"_id":"themes/Yelee/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1464546868000},{"_id":"themes/Yelee/languages/default.yml","hash":"80cc17267333753accc0b1c85a73678fedcbce76","modified":1464546904000},{"_id":"themes/Yelee/languages/en.yml","hash":"2c096d06c0af4ddf9c128fc8f77fb276b59a47fb","modified":1464546904000},{"_id":"themes/Yelee/.git/packed-refs","hash":"e4fa8baa5200a3a37d2d8e0c8b2bc0f41e0527c4","modified":1464546904000},{"_id":"themes/Yelee/.git/index","hash":"297a49bff9b26a9126646eba5dd4cb093fe0f17b","modified":1464547263000},{"_id":"themes/Yelee/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1464546905000},{"_id":"themes/Yelee/languages/zh-Hant-TW.yml","hash":"f372cc0d758a7d8bbb885aa9756d607bec26469a","modified":1464546904000},{"_id":"themes/Yelee/languages/zh-Hans.yml","hash":"b5b2d20cde04db3773962284a002d025b09134b0","modified":1464546904000},{"_id":"themes/Yelee/languages/zh-Hant-HK.yml","hash":"c38a95f5076ad951839aaf7748295d7eea277c61","modified":1464546904000},{"_id":"themes/Yelee/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1464546905000},{"_id":"themes/Yelee/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1464546905000},{"_id":"themes/Yelee/layout/layout.ejs","hash":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1464546905000},{"_id":"themes/Yelee/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1464546905000},{"_id":"themes/Yelee/source/apple-touch-icon.png","hash":"c0fda117fa166d63b9eb690cc5e4fb2caaf493b3","modified":1464546905000},{"_id":"themes/Yelee/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1464546905000},{"_id":"themes/Yelee/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1464546905000},{"_id":"themes/Yelee/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1464546868000},{"_id":"themes/Yelee/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1464546868000},{"_id":"themes/Yelee/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1464546868000},{"_id":"themes/Yelee/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1464546868000},{"_id":"themes/Yelee/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1464546868000},{"_id":"themes/Yelee/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1464546868000},{"_id":"themes/Yelee/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1464546868000},{"_id":"themes/Yelee/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1464546868000},{"_id":"themes/Yelee/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1464546868000},{"_id":"themes/Yelee/.git/logs/HEAD","hash":"888b5cadcb2cb4f68daa1c3cbf60d20e69f6bb1d","modified":1464546904000},{"_id":"themes/Yelee/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1464546868000},{"_id":"themes/Yelee/layout/_partial/after-footer.ejs","hash":"60906cb6c6d8ced0196f785c40c3e10dab649d4d","modified":1464546904000},{"_id":"themes/Yelee/layout/_partial/archive-post.ejs","hash":"0ecc2ad07b4abad80f564ac1858c50bcbdff34f8","modified":1464546904000},{"_id":"themes/Yelee/layout/_partial/background.ejs","hash":"aeef39abef66ee0bd6c9efe856eaeb1b81416d41","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/article.ejs","hash":"29749e14db1a5f1ab5e82f486ac0c7f8417c86c0","modified":1464546904000},{"_id":"themes/Yelee/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1464546904000},{"_id":"themes/Yelee/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/head.ejs","hash":"5a48d6da7b338d1295fbe6bf2715644a94591b84","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/footer.ejs","hash":"7e8902fb47bc37b7534936e55312522a9721338e","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/ie-updater.ejs","hash":"3e5f2e41bbb1a5b93a8a7a6cb9ccd191ced54408","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/mobile-nav.ejs","hash":"306be982577b0ef968f855d0dfeaab6b180b8a50","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/page.ejs","hash":"cfce60062cdb60893baeda7fa0266ae4086c2bc8","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/mathjax.ejs","hash":"ce868f8b2b5b377cadc270e3a5bb5826f8bf0dee","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/left-col.ejs","hash":"06c5fa07ee00abd62198f33d5e29928fb192b588","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/post-nav-button.ejs","hash":"0a98bffdd14f6677721841c0ac4487a86c77266c","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/tag-cloud-page.ejs","hash":"432ded02bcc1f0d52cd833e8eeac688ee886169a","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/toc.ejs","hash":"5ff80e66e6911a6f62a9e53b74556a14d09c4cef","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/scrolling-button.ejs","hash":"bfc245d99cca8e325f7c34b985a769ff780f28a6","modified":1464546905000},{"_id":"themes/Yelee/source/background/bg-1.jpg","hash":"31d7bb15211000c05656899302f8ec9ee3de0e9f","modified":1464546905000},{"_id":"themes/Yelee/source/background/bg-2.jpg","hash":"d1e0b92e8fa822e44d185b5e1bf94ab47bc98a0a","modified":1464546905000},{"_id":"themes/Yelee/source/background/bg-5.jpg","hash":"d476909f06fe8267c676952e3582bf9e9ff73585","modified":1464546905000},{"_id":"themes/Yelee/source/background/bg-3.jpg","hash":"7ae358f3ab8b41558444053400e796c41b3ba0e2","modified":1464546905000},{"_id":"themes/Yelee/source/background/bg-4.jpg","hash":"9a5241de4c880f13a278f6980bf11d4dfb214d82","modified":1464546905000},{"_id":"themes/Yelee/source/background/bg-7.jpg","hash":"1a06d3a660bfb99b62d760e4e1e09de168a4c74c","modified":1464546905000},{"_id":"themes/Yelee/source/background/bg-6.jpg","hash":"6df1383d0f6134016d844df9abb740a6e0c0b2c5","modified":1464546905000},{"_id":"themes/Yelee/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1464546905000},{"_id":"themes/Yelee/source/js/GithubRepoWidget.js","hash":"624e81a3b0e57495b0c0e0b3e056296c6e8ae5df","modified":1464546905000},{"_id":"themes/Yelee/source/background/bg-8.jpg","hash":"8e80d0b7786c3bf7b9648c0190719e78001e9eeb","modified":1464546905000},{"_id":"themes/Yelee/source/js/search.js","hash":"b456aaab98bbc3b0906f8a16d1e6e4f74dfcffda","modified":1464546905000},{"_id":"themes/Yelee/source/js/pc.js","hash":"53da12fd8bb42043933258694574fa47411e39a2","modified":1464546905000},{"_id":"themes/Yelee/source/js/mobile.js","hash":"8abc32d18f16db56f51caad607cffb6ca756eca9","modified":1464546905000},{"_id":"themes/Yelee/source/js/main.js","hash":"356b59ea1fbac4eb495d487e1f40c8dbf9941127","modified":1464546905000},{"_id":"themes/Yelee/source/img/Plunker.png","hash":"0866ed3cd6281d4f948d154c527b39bf2cdade1b","modified":1464546905000},{"_id":"themes/Yelee/source/img/CSDN.png","hash":"aad4bd4b0dfd63f81849a7447a69cc93fcf2d430","modified":1464546905000},{"_id":"themes/Yelee/source/img/TiddlyWiki.png","hash":"6c181145a7033847df3663e10c136590dbab2ba6","modified":1464546905000},{"_id":"themes/Yelee/source/img/SegmentFault.png","hash":"6129d1e73e1c9e36c18ab887d04a1461f1af9635","modified":1464546905000},{"_id":"themes/Yelee/source/img/V2EX.png","hash":"f0caf915a5ce1a5fb96d7ed7bd2aad9ce0d3e243","modified":1464546905000},{"_id":"themes/Yelee/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1464546905000},{"_id":"themes/Yelee/source/img/avatar.png","hash":"c0fda117fa166d63b9eb690cc5e4fb2caaf493b3","modified":1464546905000},{"_id":"themes/Yelee/source/img/简书.png","hash":"a1b837849522cc2956317e511b076831bb7acd8c","modified":1464546905000},{"_id":"themes/Yelee/source/img/知乎.png","hash":"2da06acf9e8026d9ac0a719844a6fae142271c14","modified":1464546905000},{"_id":"themes/Yelee/source/img/新浪微博.png","hash":"40b9099a802ee7ca40f58ab013e5faad5b3f8ed5","modified":1464546905000},{"_id":"themes/Yelee/source/img/博客园.png","hash":"8bd54005ce0fee7a5ee70e0cce5369a93ef8316c","modified":1464546905000},{"_id":"themes/Yelee/source/img/豆瓣.png","hash":"caa6021d0c35f11744f03d23a2c12f7734041562","modified":1464546905000},{"_id":"themes/Yelee/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1464546905000},{"_id":"themes/Yelee/source/img/虾米音乐.png","hash":"8e3065d8ea3a3d07b23d4cfc10ceb626c67a926a","modified":1464546905000},{"_id":"themes/Yelee/source/img/网易云音乐.png","hash":"9620f5025d6e2614d82ace771ddfe708362220c4","modified":1464546905000},{"_id":"themes/Yelee/source/css/style.styl","hash":"4891bbfae51f66a75f2a1021fa3a891f3f631461","modified":1464546905000},{"_id":"themes/Yelee/source/css/_variables.styl","hash":"803faa7a85d9fafb8072a2abd912b46c546eee92","modified":1464546905000},{"_id":"themes/Yelee/source/img/BO7190VR00BV0005.jpg","hash":"ab8ac90a09db76de0ba48fa41581d22f8893bfeb","modified":1464529326000},{"_id":"themes/Yelee/source/background/bg-10.jpg","hash":"51b427f07ffc6f2ad97651f23cc16e8f19ed02f9","modified":1464546905000},{"_id":"themes/Yelee/source/background/bg-9.jpg","hash":"e4a3631b6b0f94ebce30a6f01ecb2b6ed7cfdb0b","modified":1464546905000},{"_id":"themes/Yelee/.git/refs/heads/master","hash":"b2e2192798f830a77f569269436c130f25a88926","modified":1464546904000},{"_id":"themes/Yelee/layout/_partial/comments/disqus.ejs","hash":"2e5cad68bc59190b4158f4ab1879a222ca49a0d2","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/comments/duoshuo.ejs","hash":"1f9ac8182fe0b867a8f1988888336c40c25894cd","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/comments/youyan.ejs","hash":"a6853b59ee60e775de1ed90b242084f83774d195","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/post/category.ejs","hash":"08c8d98bc6a73d3f72a3b0b30521ff28e1b657a7","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/post/date.ejs","hash":"a9fc6bac9e1b90c1c17c0d0ffd97f9b108072fbe","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/post/nav.ejs","hash":"6f531dbc9cc7ae42d2486d6707f826cfe7d9d8bc","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/post/tag.ejs","hash":"7d2693a1162bf26e4b1ae9b789e0b2a2637ddbd5","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/post/share.ejs","hash":"58c2db54a9867aaafe68a7f052b04701c7c3df0f","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/archive.styl","hash":"27ccc6374d04cd93717a2b6c587342b6cbe6fc80","modified":1464546905000},{"_id":"themes/Yelee/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/article.styl","hash":"a14120bbce2c384d8df1662e18fa47f75f519a18","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/footer.styl","hash":"e920a40d228b844f8636ae3c1c202850e779e38d","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/highlight.styl","hash":"19b7eba61553060fda25999b2a61d0e7b5e072a3","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/instagram.styl","hash":"a093443add2f529396d6b6bdef1675bc3acf3958","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/main.styl","hash":"d6e60382783b2a0fb865519dd1b7760d356d8037","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/mobile-slider.styl","hash":"39db458d4e9f6973afc1390b4d3fc0291fff4c40","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/mobile.styl","hash":"ae594540c6685b490c6ced196f75cb5e3ca7dae0","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/page.styl","hash":"ca3f871adf8fdb296e4394070605dded53d93cb2","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/scroll.styl","hash":"f32deb9192568a2ea789d77a23a08d07f4e57d59","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/search.styl","hash":"fcaa5deaa654aaec69e267e23b49df07f84f633a","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/share.styl","hash":"88c1277397b71eb1f3473a94d9542314f983cd09","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/tagcloud.styl","hash":"b38b275728bfe11809defe1077b03cb423c3c92f","modified":1464546905000},{"_id":"themes/Yelee/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1464546905000},{"_id":"themes/Yelee/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1464546905000},{"_id":"themes/Yelee/.git/objects/pack/pack-08364f7b67dfc73cee2cd032a36ef58ad5dcd9e4.idx","hash":"d4226833f9d4e60c8f8b66f57ec6ed7934d716f3","modified":1464546904000},{"_id":"themes/Yelee/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1464546904000},{"_id":"themes/Yelee/.git/logs/refs/heads/master","hash":"888b5cadcb2cb4f68daa1c3cbf60d20e69f6bb1d","modified":1464546904000},{"_id":"themes/Yelee/source/css/_partial/customise/blockquote.styl","hash":"4c71df7426fa7325218929465111aa5b2ec5bd8c","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/customise/code-block.styl","hash":"4db1a992a06fd92b779f0afc9bb8bb3667bdb101","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/customise/heading.styl","hash":"193d7881407ec8cde227802385269bd1667a7d49","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/customise/color-scheme.styl","hash":"b58262a9f8903e75df431291745e19ccd8ff243a","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/customise/inline-code.styl","hash":"aedbcd697c9fbaeeb93c068be3db771c41feba0d","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/customise/list.styl","hash":"b1e564ed76d6e892556b61b4278270fc9eeea961","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/customise/social-icon.styl","hash":"f686fd5d6e41f749ad860971fbda5a108fbf32f5","modified":1464546905000},{"_id":"themes/Yelee/source/css/_partial/post/youyan.styl","hash":"ac2869e2e0fb3a1ee0df4b0c0a233a2b1923ea20","modified":1464546905000},{"_id":"themes/Yelee/.git/logs/refs/remotes/origin/HEAD","hash":"888b5cadcb2cb4f68daa1c3cbf60d20e69f6bb1d","modified":1464546904000},{"_id":"themes/Yelee/.git/objects/pack/pack-08364f7b67dfc73cee2cd032a36ef58ad5dcd9e4.pack","hash":"04178c7e2cac29c23a11df0b24e221ff6802334b","modified":1464546904000}],"Category":[],"Data":[],"Page":[{"title":"ljw","date":"2016-05-30T05:50:15.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: ljw\ndate: 2016-05-30 13:50:15\n---\n","updated":"2016-05-30T05:53:04.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ciotn328600044qojtnfi6y8a","content":"","excerpt":"","more":""}],"Post":[{"title":"我的代码","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n+ <!-- more -->\n## Quick Start\n\n### 代码示例>\n\n``` objc\n- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated\n{\n    //自定义返回按钮\n    if (self.childViewControllers.count) {\n        \n        UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];\n        [btn setImage:[UIImage imageNamed:@\"navigationButtonReturn\"] forState:UIControlStateNormal];\n        [btn setImage:[UIImage imageNamed:@\"navigationButtonReturnClick\"] forState:UIControlStateHighlighted];\n        [btn setTitle:@\"返回\" forState:UIControlStateNormal];\n        [btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];\n        [btn setTitleColor:[UIColor redColor] forState:UIControlStateHighlighted];\n        [btn addTarget:self action:@selector(back) forControlEvents:UIControlEventTouchUpInside];\n        [btn sizeToFit];\n        \n        //设置返回按钮向左偏移一点\n        btn.contentEdgeInsets = UIEdgeInsetsMake(0, -30, 0, 0);\n        \n        viewController.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:btn];\n        //隐藏push之后的tabBar\n        viewController.hidesBottomBarWhenPushed = YES;\n    }\n    \n    [super pushViewController:viewController animated:animated];\n    \n}\n\n```\n\n","source":"_posts/123.md","raw":"---\ntitle: 我的代码\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n+ <!-- more -->\n## Quick Start\n\n### 代码示例>\n\n``` objc\n- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated\n{\n    //自定义返回按钮\n    if (self.childViewControllers.count) {\n        \n        UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];\n        [btn setImage:[UIImage imageNamed:@\"navigationButtonReturn\"] forState:UIControlStateNormal];\n        [btn setImage:[UIImage imageNamed:@\"navigationButtonReturnClick\"] forState:UIControlStateHighlighted];\n        [btn setTitle:@\"返回\" forState:UIControlStateNormal];\n        [btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];\n        [btn setTitleColor:[UIColor redColor] forState:UIControlStateHighlighted];\n        [btn addTarget:self action:@selector(back) forControlEvents:UIControlEventTouchUpInside];\n        [btn sizeToFit];\n        \n        //设置返回按钮向左偏移一点\n        btn.contentEdgeInsets = UIEdgeInsetsMake(0, -30, 0, 0);\n        \n        viewController.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:btn];\n        //隐藏push之后的tabBar\n        viewController.hidesBottomBarWhenPushed = YES;\n    }\n    \n    [super pushViewController:viewController animated:animated];\n    \n}\n\n```\n\n","slug":"123","published":1,"date":"2016-05-30T06:32:56.000Z","updated":"2016-05-30T06:36:06.000Z","_id":"ciotn326p00004qoj3twcw7l9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<ul>\n<li><a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2></li>\n</ul>\n<h3 id=\"代码示例-gt\"><a href=\"#代码示例-gt\" class=\"headerlink\" title=\"代码示例&gt;\"></a>代码示例&gt;</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pushViewController:(<span class=\"built_in\">UIViewController</span> *)viewController animated:(<span class=\"built_in\">BOOL</span>)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//自定义返回按钮</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.childViewControllers.count) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">UIButton</span> *btn = [<span class=\"built_in\">UIButton</span> buttonWithType:<span class=\"built_in\">UIButtonTypeCustom</span>];</span><br><span class=\"line\">        [btn setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"navigationButtonReturn\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">        [btn setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"navigationButtonReturnClick\"</span>] forState:<span class=\"built_in\">UIControlStateHighlighted</span>];</span><br><span class=\"line\">        [btn setTitle:<span class=\"string\">@\"返回\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">        [btn setTitleColor:[<span class=\"built_in\">UIColor</span> blackColor] forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">        [btn setTitleColor:[<span class=\"built_in\">UIColor</span> redColor] forState:<span class=\"built_in\">UIControlStateHighlighted</span>];</span><br><span class=\"line\">        [btn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(back) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">        [btn sizeToFit];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//设置返回按钮向左偏移一点</span></span><br><span class=\"line\">        btn.contentEdgeInsets = <span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">0</span>, <span class=\"number\">-30</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        viewController.navigationItem.leftBarButtonItem = [[<span class=\"built_in\">UIBarButtonItem</span> alloc] initWithCustomView:btn];</span><br><span class=\"line\">        <span class=\"comment\">//隐藏push之后的tabBar</span></span><br><span class=\"line\">        viewController.hidesBottomBarWhenPushed = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">super</span> pushViewController:viewController animated:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<ul>\n<li>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2></li>\n</ul>\n<h3 id=\"代码示例-gt\"><a href=\"#代码示例-gt\" class=\"headerlink\" title=\"代码示例&gt;\"></a>代码示例&gt;</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pushViewController:(<span class=\"built_in\">UIViewController</span> *)viewController animated:(<span class=\"built_in\">BOOL</span>)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//自定义返回按钮</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.childViewControllers.count) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">UIButton</span> *btn = [<span class=\"built_in\">UIButton</span> buttonWithType:<span class=\"built_in\">UIButtonTypeCustom</span>];</span><br><span class=\"line\">        [btn setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"navigationButtonReturn\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">        [btn setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"navigationButtonReturnClick\"</span>] forState:<span class=\"built_in\">UIControlStateHighlighted</span>];</span><br><span class=\"line\">        [btn setTitle:<span class=\"string\">@\"返回\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">        [btn setTitleColor:[<span class=\"built_in\">UIColor</span> blackColor] forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">        [btn setTitleColor:[<span class=\"built_in\">UIColor</span> redColor] forState:<span class=\"built_in\">UIControlStateHighlighted</span>];</span><br><span class=\"line\">        [btn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(back) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">        [btn sizeToFit];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//设置返回按钮向左偏移一点</span></span><br><span class=\"line\">        btn.contentEdgeInsets = <span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">0</span>, <span class=\"number\">-30</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        viewController.navigationItem.leftBarButtonItem = [[<span class=\"built_in\">UIBarButtonItem</span> alloc] initWithCustomView:btn];</span><br><span class=\"line\">        <span class=\"comment\">//隐藏push之后的tabBar</span></span><br><span class=\"line\">        viewController.hidesBottomBarWhenPushed = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">super</span> pushViewController:viewController animated:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n+ <!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n+ <!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n\n","slug":"hello-world","published":1,"date":"2016-05-29T17:28:16.000Z","updated":"2016-05-30T06:25:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciotn326z00014qojdgzq9hs8","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<ul>\n<li><a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2></li>\n</ul>\n<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<ul>\n<li>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2></li>\n</ul>\n<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n+ <!-- more -->\n## 从iOS9开始的常见报错\n```objc\nApplication windows are expected to have a root view controller at the end of application launch\n```\n- 从iOS9开始, 在`程序启动完毕那一刻`显示出来的窗口`必须`要设置`根控制器`\n\n## 应用程序的图标\n- 旧项目中的图标只要符合1个条件即可\n    - 图片名叫做Icon.png\n\n## 有些图片显示出来会自动渲染成蓝色\n#### 比如\n- 设置tabBarItem的选中图片\n\n```objc\nvc.tabBarItem.selectedImage = image;\n```\n\n- 设置UIButtonTypeSystem样式按钮的image时\n\n```objc\nUIButton *btn = [UIButton buttonWithType:UIButtonTypeSystem];\n[btn setImage:image forState:UIControlStateNormal];\n```\n\n#### 解决方案\n- 再次产生一张不会进行渲染的图片\n\n```objc\n// 加载图片\nUIImage *tempImage = [UIImage imageNamed:@\"tabBar_essence_click_icon\"];\n// 产生一张不会进行自动渲染的图片\nUIImage *selectedImage = [tempImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];\nvc.tabBarItem.selectedImage = selectedImage;\n```\n\n- 直接在xcassets文件中配置\n![image](Images/Snip20151105_1.png)\n\n## 设置TabBarItem的文字属性\n- 直接设置每一个tabBarItem对象\n\n```objc\n// 普通状态下的文字属性\nNSMutableDictionary *normalAttrs = [NSMutableDictionary dictionary];\nnormalAttrs[NSFontAttributeName] = [UIFont systemFontOfSize:14];\nnormalAttrs[NSForegroundColorAttributeName] = [UIColor grayColor];\n[vc.tabBarItem setTitleTextAttributes:normalAttrs forState:UIControlStateNormal];\n\n// 选中状态下的文字属性\nNSMutableDictionary *selectedAttrs = [NSMutableDictionary dictionary];\nselectedAttrs[NSForegroundColorAttributeName] = [UIColor darkGrayColor];\n[vc.tabBarItem setTitleTextAttributes:selectedAttrs forState:UIControlStateSelected];\n\n// 字典中用到的key\n1.iOS7之前(在UIStringDrawing.h中可以找到)\n- 比如UITextAttributeFont\\UITextAttributeTextColor\n- 规律:UITextAttributeXXX\n\n2.iOS7开始(在NSAttributedString.h中可以找到)\n- 比如NSFontAttributeName\\NSForegroundColorAttributeName\n- 规律:NSXXXAttributeName\n```\n\n- 通过UITabBarItem的appearance对象统一设置\n\n```objc\n/**** 设置所有UITabBarItem的文字属性 ****/\nUITabBarItem *item = [UITabBarItem appearance];\n// 普通状态下的文字属性\nNSMutableDictionary *normalAttrs = [NSMutableDictionary dictionary];\nnormalAttrs[NSFontAttributeName] = [UIFont systemFontOfSize:14];\nnormalAttrs[NSForegroundColorAttributeName] = [UIColor grayColor];\n[item setTitleTextAttributes:normalAttrs forState:UIControlStateNormal];\n// 选中状态下的文字属性\nNSMutableDictionary *selectedAttrs = [NSMutableDictionary dictionary];\nselectedAttrs[NSForegroundColorAttributeName] = [UIColor darkGrayColor];\n[item setTitleTextAttributes:normalAttrs forState:UIControlStateSelected];\n```\n\n\n## 项目的图片资源\n- 可以利用一个Mac软件解压\n    - https://github.com/devcxm/iOS-Images-Extractor\n\n## 颜色相关的一些知识\n- 颜色的基本组成\n    - 一种颜色由N个颜色通道组成\n- 颜色通道\n    - 1个颜色通道占据8bit\n    - 1个颜色通道的取值范围\n        - 10进制 : [0, 255]\n        - 16进制 : [00, ff];\n    - 常见的颜色通道\n        - 红色 red R\n        - 绿色 green G\n        - 蓝色 blue B\n        - 透明度 alpha A\n    -  R\\G\\B一样的是灰色\n- 颜色的种类\n    - 24bit颜色\n        - 由R\\G\\B组成的颜色\n        - 常见的表示形式\n            - 10进制(`仅仅是用在CSS`)\n                - 红色 : rgb(255,0,0)\n                - 绿色 : rgb(0,255,0)\n                - 蓝色 : rgb(0,0,255)\n                - 黄色 : rgb(255,255,0)\n                - 黑色 : rgb(0,0,0)\n                - 白色 : rgb(255,255,255)\n                - 灰色 : rgb(80,80,80)\n            - 16进制(`可以用在CSS\\android`)\n                - 红色 : #ff0000  #f00\n                - 绿色 : #00ff00  #0f0\n                - 蓝色 : #0000ff  #00f\n                - 黄色 : #ffff00  #ff0\n                - 黑色 : #000000  #000\n                - 白色 : #ffffff  #fff\n                - 灰色 : #979797\n    - 32bit颜色\n        - 由R\\G\\B\\A组成的颜色\n        - 常见的表示形式\n            - 10进制(`仅仅是用在CSS`)\n                - 红色 : rgba(255,0,0,255)\n                - 绿色 : rgba(0,255,0,255)\n                - 蓝色 : rgba(0,0,255,255)\n                - 黄色 : rgba(255,255,0,255)\n                - 黑色 : rgba(0,0,0,255)\n                - 白色 : rgba(255,255,255,255)\n            - 16进制(#AARRGGBB,  `仅仅是用在android`)\n                - 红色 : #ffff0000\n                - 绿色 : #ff00ff00\n                - 蓝色 : #ff0000ff\n                - 黄色 : #ffffff00\n                - 黑色 : #ff000000\n                - 白色 : #ffffffff\n\n## PCH文件可能引发的错误\n![image](Images/Snip20151105_8.png)\n- 解决方案\n\n```objc\n#ifndef PrefixHeader_pch\n#define PrefixHeader_pch\n\n/*** 如果希望某些内容能拷贝到任何源代码文件(OC\\C\\C++等), 那么就不要写在#ifdef __OBJC__和#endif之间 ***/\n\n\n/***** 在#ifdef __OBJC__和#endif之间的内容, 只会拷贝到OC源代码文件中, 不会拷贝到其他语言的源代码文件中 *****/\n#ifdef __OBJC__\n\n\n#endif\n/***** 在#ifdef __OBJC__和#endif之间的内容, 只会拷贝到OC源代码文件中, 不会拷贝到其他语言的源代码文件中 *****/\n\n\n#endif\n```\n\n## 在Build Setting中配置宏\n- 如果项目中有些宏找不到, 可能是配置在Build Setting中\n![image](Images/Snip20151105_9.png)\n\n- 注意点:宏的名字不能全部是小写字母\n\n- 如果宏的名字全部是小写, 会出现以下错误\n![image](Images/Snip20151105_10.png)\n\n## Appearance的使用场合\n- 只要后面带有`UI_APPEARANCE_SELECTOR`的方法或者属性,都可以通过appearance对象统一设置\n- 比如\n\n```objc\n@interface UISwitch : UIControl <NSCoding>\n\n@property(nullable, nonatomic, strong) UIColor *onTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;\n\n@end\n\nUISwitch *s = [UISwitch appearance];\ns.onTintColor = [UIColor redColor];\n```\n\n","source":"_posts/hello-world副本.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n+ <!-- more -->\n## 从iOS9开始的常见报错\n```objc\nApplication windows are expected to have a root view controller at the end of application launch\n```\n- 从iOS9开始, 在`程序启动完毕那一刻`显示出来的窗口`必须`要设置`根控制器`\n\n## 应用程序的图标\n- 旧项目中的图标只要符合1个条件即可\n    - 图片名叫做Icon.png\n\n## 有些图片显示出来会自动渲染成蓝色\n#### 比如\n- 设置tabBarItem的选中图片\n\n```objc\nvc.tabBarItem.selectedImage = image;\n```\n\n- 设置UIButtonTypeSystem样式按钮的image时\n\n```objc\nUIButton *btn = [UIButton buttonWithType:UIButtonTypeSystem];\n[btn setImage:image forState:UIControlStateNormal];\n```\n\n#### 解决方案\n- 再次产生一张不会进行渲染的图片\n\n```objc\n// 加载图片\nUIImage *tempImage = [UIImage imageNamed:@\"tabBar_essence_click_icon\"];\n// 产生一张不会进行自动渲染的图片\nUIImage *selectedImage = [tempImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];\nvc.tabBarItem.selectedImage = selectedImage;\n```\n\n- 直接在xcassets文件中配置\n![image](Images/Snip20151105_1.png)\n\n## 设置TabBarItem的文字属性\n- 直接设置每一个tabBarItem对象\n\n```objc\n// 普通状态下的文字属性\nNSMutableDictionary *normalAttrs = [NSMutableDictionary dictionary];\nnormalAttrs[NSFontAttributeName] = [UIFont systemFontOfSize:14];\nnormalAttrs[NSForegroundColorAttributeName] = [UIColor grayColor];\n[vc.tabBarItem setTitleTextAttributes:normalAttrs forState:UIControlStateNormal];\n\n// 选中状态下的文字属性\nNSMutableDictionary *selectedAttrs = [NSMutableDictionary dictionary];\nselectedAttrs[NSForegroundColorAttributeName] = [UIColor darkGrayColor];\n[vc.tabBarItem setTitleTextAttributes:selectedAttrs forState:UIControlStateSelected];\n\n// 字典中用到的key\n1.iOS7之前(在UIStringDrawing.h中可以找到)\n- 比如UITextAttributeFont\\UITextAttributeTextColor\n- 规律:UITextAttributeXXX\n\n2.iOS7开始(在NSAttributedString.h中可以找到)\n- 比如NSFontAttributeName\\NSForegroundColorAttributeName\n- 规律:NSXXXAttributeName\n```\n\n- 通过UITabBarItem的appearance对象统一设置\n\n```objc\n/**** 设置所有UITabBarItem的文字属性 ****/\nUITabBarItem *item = [UITabBarItem appearance];\n// 普通状态下的文字属性\nNSMutableDictionary *normalAttrs = [NSMutableDictionary dictionary];\nnormalAttrs[NSFontAttributeName] = [UIFont systemFontOfSize:14];\nnormalAttrs[NSForegroundColorAttributeName] = [UIColor grayColor];\n[item setTitleTextAttributes:normalAttrs forState:UIControlStateNormal];\n// 选中状态下的文字属性\nNSMutableDictionary *selectedAttrs = [NSMutableDictionary dictionary];\nselectedAttrs[NSForegroundColorAttributeName] = [UIColor darkGrayColor];\n[item setTitleTextAttributes:normalAttrs forState:UIControlStateSelected];\n```\n\n\n## 项目的图片资源\n- 可以利用一个Mac软件解压\n    - https://github.com/devcxm/iOS-Images-Extractor\n\n## 颜色相关的一些知识\n- 颜色的基本组成\n    - 一种颜色由N个颜色通道组成\n- 颜色通道\n    - 1个颜色通道占据8bit\n    - 1个颜色通道的取值范围\n        - 10进制 : [0, 255]\n        - 16进制 : [00, ff];\n    - 常见的颜色通道\n        - 红色 red R\n        - 绿色 green G\n        - 蓝色 blue B\n        - 透明度 alpha A\n    -  R\\G\\B一样的是灰色\n- 颜色的种类\n    - 24bit颜色\n        - 由R\\G\\B组成的颜色\n        - 常见的表示形式\n            - 10进制(`仅仅是用在CSS`)\n                - 红色 : rgb(255,0,0)\n                - 绿色 : rgb(0,255,0)\n                - 蓝色 : rgb(0,0,255)\n                - 黄色 : rgb(255,255,0)\n                - 黑色 : rgb(0,0,0)\n                - 白色 : rgb(255,255,255)\n                - 灰色 : rgb(80,80,80)\n            - 16进制(`可以用在CSS\\android`)\n                - 红色 : #ff0000  #f00\n                - 绿色 : #00ff00  #0f0\n                - 蓝色 : #0000ff  #00f\n                - 黄色 : #ffff00  #ff0\n                - 黑色 : #000000  #000\n                - 白色 : #ffffff  #fff\n                - 灰色 : #979797\n    - 32bit颜色\n        - 由R\\G\\B\\A组成的颜色\n        - 常见的表示形式\n            - 10进制(`仅仅是用在CSS`)\n                - 红色 : rgba(255,0,0,255)\n                - 绿色 : rgba(0,255,0,255)\n                - 蓝色 : rgba(0,0,255,255)\n                - 黄色 : rgba(255,255,0,255)\n                - 黑色 : rgba(0,0,0,255)\n                - 白色 : rgba(255,255,255,255)\n            - 16进制(#AARRGGBB,  `仅仅是用在android`)\n                - 红色 : #ffff0000\n                - 绿色 : #ff00ff00\n                - 蓝色 : #ff0000ff\n                - 黄色 : #ffffff00\n                - 黑色 : #ff000000\n                - 白色 : #ffffffff\n\n## PCH文件可能引发的错误\n![image](Images/Snip20151105_8.png)\n- 解决方案\n\n```objc\n#ifndef PrefixHeader_pch\n#define PrefixHeader_pch\n\n/*** 如果希望某些内容能拷贝到任何源代码文件(OC\\C\\C++等), 那么就不要写在#ifdef __OBJC__和#endif之间 ***/\n\n\n/***** 在#ifdef __OBJC__和#endif之间的内容, 只会拷贝到OC源代码文件中, 不会拷贝到其他语言的源代码文件中 *****/\n#ifdef __OBJC__\n\n\n#endif\n/***** 在#ifdef __OBJC__和#endif之间的内容, 只会拷贝到OC源代码文件中, 不会拷贝到其他语言的源代码文件中 *****/\n\n\n#endif\n```\n\n## 在Build Setting中配置宏\n- 如果项目中有些宏找不到, 可能是配置在Build Setting中\n![image](Images/Snip20151105_9.png)\n\n- 注意点:宏的名字不能全部是小写字母\n\n- 如果宏的名字全部是小写, 会出现以下错误\n![image](Images/Snip20151105_10.png)\n\n## Appearance的使用场合\n- 只要后面带有`UI_APPEARANCE_SELECTOR`的方法或者属性,都可以通过appearance对象统一设置\n- 比如\n\n```objc\n@interface UISwitch : UIControl <NSCoding>\n\n@property(nullable, nonatomic, strong) UIColor *onTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;\n\n@end\n\nUISwitch *s = [UISwitch appearance];\ns.onTintColor = [UIColor redColor];\n```\n\n","slug":"hello-world副本","published":1,"date":"2016-05-29T17:28:16.000Z","updated":"2016-05-30T06:31:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciotn327300024qojn437b9j7","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<ul>\n<li><a id=\"more\"></a>\n<h2 id=\"从iOS9开始的常见报错\"><a href=\"#从iOS9开始的常见报错\" class=\"headerlink\" title=\"从iOS9开始的常见报错\"></a>从iOS9开始的常见报错</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application windows are expected to have a root view controller at the end of application launch</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>从iOS9开始, 在<code>程序启动完毕那一刻</code>显示出来的窗口<code>必须</code>要设置<code>根控制器</code></li>\n</ul>\n<h2 id=\"应用程序的图标\"><a href=\"#应用程序的图标\" class=\"headerlink\" title=\"应用程序的图标\"></a>应用程序的图标</h2><ul>\n<li>旧项目中的图标只要符合1个条件即可<ul>\n<li>图片名叫做Icon.png</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"有些图片显示出来会自动渲染成蓝色\"><a href=\"#有些图片显示出来会自动渲染成蓝色\" class=\"headerlink\" title=\"有些图片显示出来会自动渲染成蓝色\"></a>有些图片显示出来会自动渲染成蓝色</h2><h4 id=\"比如\"><a href=\"#比如\" class=\"headerlink\" title=\"比如\"></a>比如</h4><ul>\n<li>设置tabBarItem的选中图片</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vc.tabBarItem.selectedImage = image;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>设置UIButtonTypeSystem样式按钮的image时</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIButton</span> *btn = [<span class=\"built_in\">UIButton</span> buttonWithType:<span class=\"built_in\">UIButtonTypeSystem</span>];</span><br><span class=\"line\">[btn setImage:image forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br></pre></td></tr></table></figure>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ul>\n<li>再次产生一张不会进行渲染的图片</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加载图片</span></span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *tempImage = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"tabBar_essence_click_icon\"</span>];</span><br><span class=\"line\"><span class=\"comment\">// 产生一张不会进行自动渲染的图片</span></span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *selectedImage = [tempImage imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysOriginal</span>];</span><br><span class=\"line\">vc.tabBarItem.selectedImage = selectedImage;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>直接在xcassets文件中配置<br><img src=\"Images/Snip20151105_1.png\" alt=\"image\"></li>\n</ul>\n<h2 id=\"设置TabBarItem的文字属性\"><a href=\"#设置TabBarItem的文字属性\" class=\"headerlink\" title=\"设置TabBarItem的文字属性\"></a>设置TabBarItem的文字属性</h2><ul>\n<li>直接设置每一个tabBarItem对象</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 普通状态下的文字属性</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *normalAttrs = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">normalAttrs[<span class=\"built_in\">NSFontAttributeName</span>] = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">14</span>];</span><br><span class=\"line\">normalAttrs[<span class=\"built_in\">NSForegroundColorAttributeName</span>] = [<span class=\"built_in\">UIColor</span> grayColor];</span><br><span class=\"line\">[vc.tabBarItem setTitleTextAttributes:normalAttrs forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 选中状态下的文字属性</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *selectedAttrs = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">selectedAttrs[<span class=\"built_in\">NSForegroundColorAttributeName</span>] = [<span class=\"built_in\">UIColor</span> darkGrayColor];</span><br><span class=\"line\">[vc.tabBarItem setTitleTextAttributes:selectedAttrs forState:<span class=\"built_in\">UIControlStateSelected</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字典中用到的key</span></span><br><span class=\"line\"><span class=\"number\">1.</span>iOS7之前(在<span class=\"built_in\">UIStringDrawing</span>.h中可以找到)</span><br><span class=\"line\">- 比如<span class=\"built_in\">UITextAttributeFont</span>\\<span class=\"built_in\">UITextAttributeTextColor</span></span><br><span class=\"line\">- 规律:<span class=\"built_in\">UITextAttributeXXX</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>iOS7开始(在<span class=\"built_in\">NSAttributedString</span>.h中可以找到)</span><br><span class=\"line\">- 比如<span class=\"built_in\">NSFontAttributeName</span>\\<span class=\"built_in\">NSForegroundColorAttributeName</span></span><br><span class=\"line\">- 规律:<span class=\"built_in\">NSXXXAttributeName</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过UITabBarItem的appearance对象统一设置</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**** 设置所有UITabBarItem的文字属性 ****/</span></span><br><span class=\"line\"><span class=\"built_in\">UITabBarItem</span> *item = [<span class=\"built_in\">UITabBarItem</span> appearance];</span><br><span class=\"line\"><span class=\"comment\">// 普通状态下的文字属性</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *normalAttrs = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">normalAttrs[<span class=\"built_in\">NSFontAttributeName</span>] = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">14</span>];</span><br><span class=\"line\">normalAttrs[<span class=\"built_in\">NSForegroundColorAttributeName</span>] = [<span class=\"built_in\">UIColor</span> grayColor];</span><br><span class=\"line\">[item setTitleTextAttributes:normalAttrs forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\"><span class=\"comment\">// 选中状态下的文字属性</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *selectedAttrs = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">selectedAttrs[<span class=\"built_in\">NSForegroundColorAttributeName</span>] = [<span class=\"built_in\">UIColor</span> darkGrayColor];</span><br><span class=\"line\">[item setTitleTextAttributes:normalAttrs forState:<span class=\"built_in\">UIControlStateSelected</span>];</span><br></pre></td></tr></table></figure>\n<h2 id=\"项目的图片资源\"><a href=\"#项目的图片资源\" class=\"headerlink\" title=\"项目的图片资源\"></a>项目的图片资源</h2><ul>\n<li>可以利用一个Mac软件解压<ul>\n<li><a href=\"https://github.com/devcxm/iOS-Images-Extractor\" target=\"_blank\" rel=\"external\">https://github.com/devcxm/iOS-Images-Extractor</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"颜色相关的一些知识\"><a href=\"#颜色相关的一些知识\" class=\"headerlink\" title=\"颜色相关的一些知识\"></a>颜色相关的一些知识</h2><ul>\n<li>颜色的基本组成<ul>\n<li>一种颜色由N个颜色通道组成</li>\n</ul>\n</li>\n<li>颜色通道<ul>\n<li>1个颜色通道占据8bit</li>\n<li>1个颜色通道的取值范围<ul>\n<li>10进制 : [0, 255]</li>\n<li>16进制 : [00, ff];</li>\n</ul>\n</li>\n<li>常见的颜色通道<ul>\n<li>红色 red R</li>\n<li>绿色 green G</li>\n<li>蓝色 blue B</li>\n<li>透明度 alpha A</li>\n</ul>\n</li>\n<li>R\\G\\B一样的是灰色</li>\n</ul>\n</li>\n<li>颜色的种类<ul>\n<li>24bit颜色<ul>\n<li>由R\\G\\B组成的颜色</li>\n<li>常见的表示形式<ul>\n<li>10进制(<code>仅仅是用在CSS</code>)<ul>\n<li>红色 : rgb(255,0,0)</li>\n<li>绿色 : rgb(0,255,0)</li>\n<li>蓝色 : rgb(0,0,255)</li>\n<li>黄色 : rgb(255,255,0)</li>\n<li>黑色 : rgb(0,0,0)</li>\n<li>白色 : rgb(255,255,255)</li>\n<li>灰色 : rgb(80,80,80)</li>\n</ul>\n</li>\n<li>16进制(<code>可以用在CSS\\android</code>)<ul>\n<li>红色 : #ff0000  #f00</li>\n<li>绿色 : #00ff00  #0f0</li>\n<li>蓝色 : #0000ff  #00f</li>\n<li>黄色 : #ffff00  #ff0</li>\n<li>黑色 : #000000  #000</li>\n<li>白色 : #ffffff  #fff</li>\n<li>灰色 : #979797</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>32bit颜色<ul>\n<li>由R\\G\\B\\A组成的颜色</li>\n<li>常见的表示形式<ul>\n<li>10进制(<code>仅仅是用在CSS</code>)<ul>\n<li>红色 : rgba(255,0,0,255)</li>\n<li>绿色 : rgba(0,255,0,255)</li>\n<li>蓝色 : rgba(0,0,255,255)</li>\n<li>黄色 : rgba(255,255,0,255)</li>\n<li>黑色 : rgba(0,0,0,255)</li>\n<li>白色 : rgba(255,255,255,255)</li>\n</ul>\n</li>\n<li>16进制(#AARRGGBB,  <code>仅仅是用在android</code>)<ul>\n<li>红色 : #ffff0000</li>\n<li>绿色 : #ff00ff00</li>\n<li>蓝色 : #ff0000ff</li>\n<li>黄色 : #ffffff00</li>\n<li>黑色 : #ff000000</li>\n<li>白色 : #ffffffff</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"PCH文件可能引发的错误\"><a href=\"#PCH文件可能引发的错误\" class=\"headerlink\" title=\"PCH文件可能引发的错误\"></a>PCH文件可能引发的错误</h2><p><img src=\"Images/Snip20151105_8.png\" alt=\"image\"></p>\n<ul>\n<li>解决方案</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifndef PrefixHeader_pch</span></span><br><span class=\"line\"><span class=\"meta\">#define PrefixHeader_pch</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*** 如果希望某些内容能拷贝到任何源代码文件(OC\\C\\C++等), 那么就不要写在#ifdef __OBJC__和#endif之间 ***/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/***** 在#ifdef __OBJC__和#endif之间的内容, 只会拷贝到OC源代码文件中, 不会拷贝到其他语言的源代码文件中 *****/</span></span><br><span class=\"line\"><span class=\"meta\">#ifdef __OBJC__</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\"><span class=\"comment\">/***** 在#ifdef __OBJC__和#endif之间的内容, 只会拷贝到OC源代码文件中, 不会拷贝到其他语言的源代码文件中 *****/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"在Build-Setting中配置宏\"><a href=\"#在Build-Setting中配置宏\" class=\"headerlink\" title=\"在Build Setting中配置宏\"></a>在Build Setting中配置宏</h2><ul>\n<li><p>如果项目中有些宏找不到, 可能是配置在Build Setting中<br><img src=\"Images/Snip20151105_9.png\" alt=\"image\"></p>\n</li>\n<li><p>注意点:宏的名字不能全部是小写字母</p>\n</li>\n<li><p>如果宏的名字全部是小写, 会出现以下错误<br><img src=\"Images/Snip20151105_10.png\" alt=\"image\"></p>\n</li>\n</ul>\n<h2 id=\"Appearance的使用场合\"><a href=\"#Appearance的使用场合\" class=\"headerlink\" title=\"Appearance的使用场合\"></a>Appearance的使用场合</h2><ul>\n<li>只要后面带有<code>UI_APPEARANCE_SELECTOR</code>的方法或者属性,都可以通过appearance对象统一设置</li>\n<li>比如</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UISwitch</span> : <span class=\"title\">UIControl</span> &lt;<span class=\"title\">NSCoding</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(nullable, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIColor</span> *onTintColor <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">5</span>_0) <span class=\"built_in\">UI_APPEARANCE_SELECTOR</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UISwitch</span> *s = [<span class=\"built_in\">UISwitch</span> appearance];</span><br><span class=\"line\">s.onTintColor = [<span class=\"built_in\">UIColor</span> redColor];</span><br></pre></td></tr></table></figure>\n","excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<ul>\n<li>","more":"<h2 id=\"从iOS9开始的常见报错\"><a href=\"#从iOS9开始的常见报错\" class=\"headerlink\" title=\"从iOS9开始的常见报错\"></a>从iOS9开始的常见报错</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application windows are expected to have a root view controller at the end of application launch</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>从iOS9开始, 在<code>程序启动完毕那一刻</code>显示出来的窗口<code>必须</code>要设置<code>根控制器</code></li>\n</ul>\n<h2 id=\"应用程序的图标\"><a href=\"#应用程序的图标\" class=\"headerlink\" title=\"应用程序的图标\"></a>应用程序的图标</h2><ul>\n<li>旧项目中的图标只要符合1个条件即可<ul>\n<li>图片名叫做Icon.png</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"有些图片显示出来会自动渲染成蓝色\"><a href=\"#有些图片显示出来会自动渲染成蓝色\" class=\"headerlink\" title=\"有些图片显示出来会自动渲染成蓝色\"></a>有些图片显示出来会自动渲染成蓝色</h2><h4 id=\"比如\"><a href=\"#比如\" class=\"headerlink\" title=\"比如\"></a>比如</h4><ul>\n<li>设置tabBarItem的选中图片</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vc.tabBarItem.selectedImage = image;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>设置UIButtonTypeSystem样式按钮的image时</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIButton</span> *btn = [<span class=\"built_in\">UIButton</span> buttonWithType:<span class=\"built_in\">UIButtonTypeSystem</span>];</span><br><span class=\"line\">[btn setImage:image forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br></pre></td></tr></table></figure>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ul>\n<li>再次产生一张不会进行渲染的图片</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加载图片</span></span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *tempImage = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"tabBar_essence_click_icon\"</span>];</span><br><span class=\"line\"><span class=\"comment\">// 产生一张不会进行自动渲染的图片</span></span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *selectedImage = [tempImage imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysOriginal</span>];</span><br><span class=\"line\">vc.tabBarItem.selectedImage = selectedImage;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>直接在xcassets文件中配置<br><img src=\"Images/Snip20151105_1.png\" alt=\"image\"></li>\n</ul>\n<h2 id=\"设置TabBarItem的文字属性\"><a href=\"#设置TabBarItem的文字属性\" class=\"headerlink\" title=\"设置TabBarItem的文字属性\"></a>设置TabBarItem的文字属性</h2><ul>\n<li>直接设置每一个tabBarItem对象</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 普通状态下的文字属性</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *normalAttrs = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">normalAttrs[<span class=\"built_in\">NSFontAttributeName</span>] = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">14</span>];</span><br><span class=\"line\">normalAttrs[<span class=\"built_in\">NSForegroundColorAttributeName</span>] = [<span class=\"built_in\">UIColor</span> grayColor];</span><br><span class=\"line\">[vc.tabBarItem setTitleTextAttributes:normalAttrs forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 选中状态下的文字属性</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *selectedAttrs = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">selectedAttrs[<span class=\"built_in\">NSForegroundColorAttributeName</span>] = [<span class=\"built_in\">UIColor</span> darkGrayColor];</span><br><span class=\"line\">[vc.tabBarItem setTitleTextAttributes:selectedAttrs forState:<span class=\"built_in\">UIControlStateSelected</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字典中用到的key</span></span><br><span class=\"line\"><span class=\"number\">1.</span>iOS7之前(在<span class=\"built_in\">UIStringDrawing</span>.h中可以找到)</span><br><span class=\"line\">- 比如<span class=\"built_in\">UITextAttributeFont</span>\\<span class=\"built_in\">UITextAttributeTextColor</span></span><br><span class=\"line\">- 规律:<span class=\"built_in\">UITextAttributeXXX</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>iOS7开始(在<span class=\"built_in\">NSAttributedString</span>.h中可以找到)</span><br><span class=\"line\">- 比如<span class=\"built_in\">NSFontAttributeName</span>\\<span class=\"built_in\">NSForegroundColorAttributeName</span></span><br><span class=\"line\">- 规律:<span class=\"built_in\">NSXXXAttributeName</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过UITabBarItem的appearance对象统一设置</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**** 设置所有UITabBarItem的文字属性 ****/</span></span><br><span class=\"line\"><span class=\"built_in\">UITabBarItem</span> *item = [<span class=\"built_in\">UITabBarItem</span> appearance];</span><br><span class=\"line\"><span class=\"comment\">// 普通状态下的文字属性</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *normalAttrs = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">normalAttrs[<span class=\"built_in\">NSFontAttributeName</span>] = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">14</span>];</span><br><span class=\"line\">normalAttrs[<span class=\"built_in\">NSForegroundColorAttributeName</span>] = [<span class=\"built_in\">UIColor</span> grayColor];</span><br><span class=\"line\">[item setTitleTextAttributes:normalAttrs forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\"><span class=\"comment\">// 选中状态下的文字属性</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *selectedAttrs = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">selectedAttrs[<span class=\"built_in\">NSForegroundColorAttributeName</span>] = [<span class=\"built_in\">UIColor</span> darkGrayColor];</span><br><span class=\"line\">[item setTitleTextAttributes:normalAttrs forState:<span class=\"built_in\">UIControlStateSelected</span>];</span><br></pre></td></tr></table></figure>\n<h2 id=\"项目的图片资源\"><a href=\"#项目的图片资源\" class=\"headerlink\" title=\"项目的图片资源\"></a>项目的图片资源</h2><ul>\n<li>可以利用一个Mac软件解压<ul>\n<li><a href=\"https://github.com/devcxm/iOS-Images-Extractor\">https://github.com/devcxm/iOS-Images-Extractor</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"颜色相关的一些知识\"><a href=\"#颜色相关的一些知识\" class=\"headerlink\" title=\"颜色相关的一些知识\"></a>颜色相关的一些知识</h2><ul>\n<li>颜色的基本组成<ul>\n<li>一种颜色由N个颜色通道组成</li>\n</ul>\n</li>\n<li>颜色通道<ul>\n<li>1个颜色通道占据8bit</li>\n<li>1个颜色通道的取值范围<ul>\n<li>10进制 : [0, 255]</li>\n<li>16进制 : [00, ff];</li>\n</ul>\n</li>\n<li>常见的颜色通道<ul>\n<li>红色 red R</li>\n<li>绿色 green G</li>\n<li>蓝色 blue B</li>\n<li>透明度 alpha A</li>\n</ul>\n</li>\n<li>R\\G\\B一样的是灰色</li>\n</ul>\n</li>\n<li>颜色的种类<ul>\n<li>24bit颜色<ul>\n<li>由R\\G\\B组成的颜色</li>\n<li>常见的表示形式<ul>\n<li>10进制(<code>仅仅是用在CSS</code>)<ul>\n<li>红色 : rgb(255,0,0)</li>\n<li>绿色 : rgb(0,255,0)</li>\n<li>蓝色 : rgb(0,0,255)</li>\n<li>黄色 : rgb(255,255,0)</li>\n<li>黑色 : rgb(0,0,0)</li>\n<li>白色 : rgb(255,255,255)</li>\n<li>灰色 : rgb(80,80,80)</li>\n</ul>\n</li>\n<li>16进制(<code>可以用在CSS\\android</code>)<ul>\n<li>红色 : #ff0000  #f00</li>\n<li>绿色 : #00ff00  #0f0</li>\n<li>蓝色 : #0000ff  #00f</li>\n<li>黄色 : #ffff00  #ff0</li>\n<li>黑色 : #000000  #000</li>\n<li>白色 : #ffffff  #fff</li>\n<li>灰色 : #979797</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>32bit颜色<ul>\n<li>由R\\G\\B\\A组成的颜色</li>\n<li>常见的表示形式<ul>\n<li>10进制(<code>仅仅是用在CSS</code>)<ul>\n<li>红色 : rgba(255,0,0,255)</li>\n<li>绿色 : rgba(0,255,0,255)</li>\n<li>蓝色 : rgba(0,0,255,255)</li>\n<li>黄色 : rgba(255,255,0,255)</li>\n<li>黑色 : rgba(0,0,0,255)</li>\n<li>白色 : rgba(255,255,255,255)</li>\n</ul>\n</li>\n<li>16进制(#AARRGGBB,  <code>仅仅是用在android</code>)<ul>\n<li>红色 : #ffff0000</li>\n<li>绿色 : #ff00ff00</li>\n<li>蓝色 : #ff0000ff</li>\n<li>黄色 : #ffffff00</li>\n<li>黑色 : #ff000000</li>\n<li>白色 : #ffffffff</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"PCH文件可能引发的错误\"><a href=\"#PCH文件可能引发的错误\" class=\"headerlink\" title=\"PCH文件可能引发的错误\"></a>PCH文件可能引发的错误</h2><p><img src=\"Images/Snip20151105_8.png\" alt=\"image\"></p>\n<ul>\n<li>解决方案</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifndef PrefixHeader_pch</span></span><br><span class=\"line\"><span class=\"meta\">#define PrefixHeader_pch</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*** 如果希望某些内容能拷贝到任何源代码文件(OC\\C\\C++等), 那么就不要写在#ifdef __OBJC__和#endif之间 ***/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/***** 在#ifdef __OBJC__和#endif之间的内容, 只会拷贝到OC源代码文件中, 不会拷贝到其他语言的源代码文件中 *****/</span></span><br><span class=\"line\"><span class=\"meta\">#ifdef __OBJC__</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\"><span class=\"comment\">/***** 在#ifdef __OBJC__和#endif之间的内容, 只会拷贝到OC源代码文件中, 不会拷贝到其他语言的源代码文件中 *****/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"在Build-Setting中配置宏\"><a href=\"#在Build-Setting中配置宏\" class=\"headerlink\" title=\"在Build Setting中配置宏\"></a>在Build Setting中配置宏</h2><ul>\n<li><p>如果项目中有些宏找不到, 可能是配置在Build Setting中<br><img src=\"Images/Snip20151105_9.png\" alt=\"image\"></p>\n</li>\n<li><p>注意点:宏的名字不能全部是小写字母</p>\n</li>\n<li><p>如果宏的名字全部是小写, 会出现以下错误<br><img src=\"Images/Snip20151105_10.png\" alt=\"image\"></p>\n</li>\n</ul>\n<h2 id=\"Appearance的使用场合\"><a href=\"#Appearance的使用场合\" class=\"headerlink\" title=\"Appearance的使用场合\"></a>Appearance的使用场合</h2><ul>\n<li>只要后面带有<code>UI_APPEARANCE_SELECTOR</code>的方法或者属性,都可以通过appearance对象统一设置</li>\n<li>比如</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UISwitch</span> : <span class=\"title\">UIControl</span> &lt;<span class=\"title\">NSCoding</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(nullable, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIColor</span> *onTintColor <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">5</span>_0) <span class=\"built_in\">UI_APPEARANCE_SELECTOR</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UISwitch</span> *s = [<span class=\"built_in\">UISwitch</span> appearance];</span><br><span class=\"line\">s.onTintColor = [<span class=\"built_in\">UIColor</span> redColor];</span><br></pre></td></tr></table></figure>"},{"title":"Block","date":"2015-12-02T16:00:00.000Z","_content":"#Block\n##block写法\n+ <!-- more -->\n\n```\nblock的写法:\n    类型:\n    返回值(^block的名称)(block的参数)\n\n    值:\n    ^(参数列表) {\n        // 执行的代码\n    };\n\n```\n\n##block基本使用\n* 作用就是用来保存一段代码块,在一个方法定义,在另外一个方法去调用(用的少,可以用定义方法替代,一般在 在一个类中定义,在另外一个类中去调用 用的比较多\n###定义的几种方式\n\n\n``` bash\n#方式一: 等号 = ^(参数){ block代码块 }\n void(^block1)(int) = ^(int a){\n        NSLog(@\"调用了block%d\",a);\n    };\n```\n* 注意点:如果block带有参数,在定义的时候,一定要有参数,并且变量名不能省略\n\n\n```\n# 方式二: 如果没有参数,参数可以省略\n    void(^block2)() = ^{\n       \n    };\n```\n\n```\n# 方式三: 等会右边 = ^返回值(参数),返回值可以省略,不管有没有返回值,都可以省略\n    int(^block3)() = ^int{\n        return 1;\n    };\n\n```\n* 注意:如果Block有返回值,block代码块必须要有返回值\n\n对于初学者,block的语法格式可能比较难记,可以尝试先用快捷的方式敲出格式,再根据生成的格式填入\n\t`block快捷方式:inline`\n\n```\n<#returnType#>(^<#blockName#>)(<#parameterTypes#>) = ^(<#parameters#>) \n{\n        <#statements#>\n};\n```\t\n\n\n###block注意事项\n* 在block内部可以访问block外部的变量\n\n```\nint a = 10;\n void (^myBlock)() = ^{\n  NSLog(@\"a = %i\", a);\n   } myBlock();\n    输出结果: 10\n```\n* block内部也可以定义和block外部的同名的变量(局部变量),此时局部变量会暂时屏蔽外部\n\n```\nint a = 10;\n void (^myBlock)() = ^{\n  int a = 50;\n   NSLog(@\"a = %i\", a);\n    } myBlock();\n     输出结果: 50\n```\n\n* 默认情况下, Block内部不能修改外面的局部变量\n\n```\nint b = 5;\n void (^myBlock)() = ^{\n  b = 20;\n// 报错 NSLog(@\"b = %i\", b);\n    };\n     myBlock();\n```\n\n* Block内部可以修改使用__block修饰的局部变量\n\n```\n__block int b = 5;\nvoid (^myBlock)() = ^{\n  b = 20;\n  NSLog(@\"b = %i\", b);\n  };\nmyBlock();\n输出结果: 20\n```\n\n* block中可以访问外面的变量\n\n* block中可以定义和外界同名的变量, 并且如果在block中定义了和外界同名的变量, 在block中访问的是block中的变量 \n* 默认情况下, 不可以在block中修改外界变量的值,因为block中的变量和外界的变量并不是同一个变量\n* 如果block中访问到了外界的变量, block会将外界的变量拷贝一份到堆内存中,因为block中使用的外界变量是copy的, 所以在调用之前修改外界变量的值, 不会影响到block中copy的值\n\n* 如果想在block中修改外界变量的值, 必须在外界变量前面加上__block ,那么会影响到外界变量的值\n\n* 如果没有添加__block是值传递\n* 如果加上__block之后就是地址传递, 所以可以在block中修改外界变量的值 \n\n\n#### 下面我们通过一个小案例来演示block的基本使用场景\n### block保存代码:\n案例:点击cell,作出相应的动作,在cell里面利用block保存代码\n* 1.在cell模型声明block属性\n\n```\n@property (nonatomic, strong) void(^block)();\n```\n* 2.在模型里面保存代码\n\n```    \n    // 打电话\n    CellItem *item = [CellItem cellItem];\n    item.title = @\"打电话\";\n    // 定义block给它\n    item.block = ^{\n        NSLog(@\"打电话\");\n    };\n```\n* 3.点击cell调用block\n\n```\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    CellItem *item = self.items[indexPath.row];\n   \n    if (item.block) {\n        item.block();\n    }\n}\n```\n### block传值\n开发中,block传值大致分为顺传和逆传\n> 顺传:比如A控制器把值传到Push之后的B控制器,就是顺传(定义属性)\n\n* 很简单,你一般只需要在在B控制器的头文件声明一个属性,A控制器拿到B控制器之后,把属性赋值,B控制器就可以拿到A传过来的值使用.\n\n>逆传:从名字就可以看出,是跟顺传反过来的,就是由B控制器反过来传回去A控制器,那么,这就没那么简单了\n\n* 逆传我们可以使用代理,但是开发中一般不会使用了,因为实在是比较麻烦,而且代码量很多,我们一般会使用block来代替代理,从而精简代码,看起来也比较容易理解\n\n先总结一下:`传值万能步骤:A传值B,A拿到B 就能传值  B传值A,拿到B就能传值`\n\n####利用block逆传\n* 1.在传递方头文件声明block属性\n\n```\n@property(nonatomic,strong)void(^block)(NSString*value);\n```\n* 2.在.m文件触发事件传值(参数)\n判断一下是否有block\n\n```\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    // 传值:\n    if (_block) {\n       _block(@\"123\");\n    }\n```\n* 3.接收方拿到传递方,拿到block接收值\n\n```\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    ModalViewController *modalVc = [[ModalViewController alloc] init];\n   \n    modalVc.block = ^(NSString *value){\n        NSLog(@\"利用了block,接收到值%@\",value);\n    };\n```\n\n```\n#好,上面简单介绍了block得传值方式,基本上开发的简单传值就是这么用的,一些复制的传值也是万变不离其宗\n```\n##block内存管理\n写在前面:为什么要理解或者掌握内存?!\n#######有一位大牛说过,你要灵活运用一个东西,就必须要知道它的内存是怎样运作,是怎么管理的,才能做到灵活运用到实际开发中\n\n>我们都知道,说到内存管理,可以分为ARC和MRC两种情况\n先来补充一下知识:\n如何判断当前项目是ARC,还是非ARC\n    1.在ARC中,不允许调用retain,release,retainCount\n    2.重写dealloc,ARC中不能调用[super dealloc]\n   \n   怎么进入非ARC环境 : 点击工程文件 -> buildSetting -> ARC\n  \n\n####1.ARC的block内存管理\nARC下,默认一个局部变量就是一个强指针,防止一创建就释放\nblock访问了一个局部变量,就会放到堆里面\n\n \t* 只要访问了一个外部变量,,生命周期不是全局的,只会放在堆里面\n   * 只要访问了一个外部变量,,生命周期是全局的,只会放在全局区\n\n只要在block代码块里面使用了self强引用就会导致循环引用\n\n\n\n```\n# 注意:只要在block的代码中,访问外部强指针对象,就会把对象强引用\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    int a = 2;\n   \n#注意:只要在block的代码中,访问外部强指针对象,就会把对象强引用\n#解决循环引用:将该对象使用weak或者block修饰符修饰之后再在block中使用/或者将其中一方强制制空 xxx = nil 。\n\n    __weak typeof(self) weakSelf = self;\n   \n    _block = ^{\n      \n        // 定义强指针的self\n        __strong typeof(self) strongSelf = weakSelf;\n       \n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n           \n            NSLog(@\"%@\",strongSelf);\n           \n        });\n       \n       \n        NSLog(@\"%d\",a);\n       \n    };\n   \n    _block(); \n}\n```\n_*从上面我们需要知道的是,什么是值传递,什么是指针传递*_\n* 值传递: 访问局部变量 \n* 指针传递:访问生命周期全局变量 \n* 而被__block修饰的局部变量,就是指针传递\n\n* 那么问题来了block是存储在堆中还是栈中?\n\n   //默认情况下block存储在栈中,如果对block进行一个copy操作, block会转移到堆中\n   //如果block在栈中, block中访问了外界的对象,那么不会对对象进行retain操作\n   //但是如果block在堆中, block中访问了外界的对象,那么会对外界的对象进行一次retain\n   \n   //如果在block中访问了外界的对象,一定要给对象加上__block,只要加上了__block,哪怕block在堆中,也不会对外界的对象进行retain\n   //如果是在ARC开发中就需要在前面加上__weak\n\n好,知道了上面的知识,你就会明白这一段代码的意思,为什么要加上这一句`__strong typeof(self) strongSelf = weakSelf;`\n我们的目的是:在要执行完那个延迟block,而且拿到对象`strongSelf`做完我们需要做的事情之后,modal出来的控制器才销毁\n如果没有一个强引用(上面那一行代码),那么,当控制器dismiss之后就释放掉那我们就拿不到`weakSelf`这个对象做事情了.\n###2.非ARC(MRC)的block内存管理\n\n只要block访问了外部变量,生命周期不是全局的(是否在代码块里面),就存放在栈里面 \n生命周期是全局的,block就存放在全局区 \n\n\nblock在非ARC中必须要使用copy  \n\n在非ARC环境下,retain相当于strong,为什么block不用retain \n因为在非arc中,是不会存放到堆里面,过了代码块就会被释放.再访问就会坏内存访问报错 \n\n在非ARC开发注意点:访问属性,一定要使用get,set方法,不能直接使用下划线\n\n\n\n####bock开发场景:参数使用 \n* 1.封装一个类的时候,有些时候,怎么去做由外界决定,但是由内部决定什么时候调用,把block当做一个参数去使用. \n\n* 2.动画block:做什么样的动画由我们决定,但是什么时候调用由系统决定. \n\n\n####bock开发场景:作为返回值使用\n这里就涉及到链式编程思想了,所谓的链式编程思想: 把所有的方法调用全部通过.语法连接起来,好处:可读性非常好\n\n```\nmgr.add(5).add(5); \n其实是分两步走,先调用mgr.add的getter,返回一个block.再跟着()实现这个block \n\n- (CalculatorManager *(^)(int))add; \n\n- (CalculatorManager *(^)(int))add\n{\n    return ^(int value){\n       \n        _result += value;\n       \n        return self;\n    }; \n}\n\n```\n\n##block在实际开发的应用举个例\n* 定义网络请求的类\n\n```\n@interface HttpTool : NSObject\n- (void)loadRequest:(void (^)())callBackBlock;\n@end\n\n@implementation HttpTool\n- (void)loadRequest:(void (^)())callBackBlock\n{\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        NSLog(@\"加载网络数据:%@\", [NSThread currentThread]);\n\n        dispatch_async(dispatch_get_main_queue(), ^{\n            callBackBlock();\n        });\n    });\n}\n@end\n```\n\n* 进行网络请求,请求到数据后利用block进行回调\n\n```\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [self.httpTool loadRequest:^{\n        NSLog(@\"主线程中,将数据回调.%@\", [NSThread currentThread]);\n    }];\n}\n``` \n\n###一些事:\n* 用strong还是copy的问题?\nblock 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.\n★建议:在ARC中,能用strong就用strong,因为copy内部会做很多事情\n\n* block是对象吗?\n是的!苹果告诉我的\\^0\\^!文档说的很清楚的\n\n\n```\n写在最后,block之强大可谓开发利器\n\t\t\t\t\t\t\t\t------make by LJW 转载请注明出处-------\n```\n\n\n\n\n\n\n","source":"_posts/开发利器-Block.md","raw":"title: Block\ndate: 2015-12-03 00:00:00\n---\n#Block\n##block写法\n+ <!-- more -->\n\n```\nblock的写法:\n    类型:\n    返回值(^block的名称)(block的参数)\n\n    值:\n    ^(参数列表) {\n        // 执行的代码\n    };\n\n```\n\n##block基本使用\n* 作用就是用来保存一段代码块,在一个方法定义,在另外一个方法去调用(用的少,可以用定义方法替代,一般在 在一个类中定义,在另外一个类中去调用 用的比较多\n###定义的几种方式\n\n\n``` bash\n#方式一: 等号 = ^(参数){ block代码块 }\n void(^block1)(int) = ^(int a){\n        NSLog(@\"调用了block%d\",a);\n    };\n```\n* 注意点:如果block带有参数,在定义的时候,一定要有参数,并且变量名不能省略\n\n\n```\n# 方式二: 如果没有参数,参数可以省略\n    void(^block2)() = ^{\n       \n    };\n```\n\n```\n# 方式三: 等会右边 = ^返回值(参数),返回值可以省略,不管有没有返回值,都可以省略\n    int(^block3)() = ^int{\n        return 1;\n    };\n\n```\n* 注意:如果Block有返回值,block代码块必须要有返回值\n\n对于初学者,block的语法格式可能比较难记,可以尝试先用快捷的方式敲出格式,再根据生成的格式填入\n\t`block快捷方式:inline`\n\n```\n<#returnType#>(^<#blockName#>)(<#parameterTypes#>) = ^(<#parameters#>) \n{\n        <#statements#>\n};\n```\t\n\n\n###block注意事项\n* 在block内部可以访问block外部的变量\n\n```\nint a = 10;\n void (^myBlock)() = ^{\n  NSLog(@\"a = %i\", a);\n   } myBlock();\n    输出结果: 10\n```\n* block内部也可以定义和block外部的同名的变量(局部变量),此时局部变量会暂时屏蔽外部\n\n```\nint a = 10;\n void (^myBlock)() = ^{\n  int a = 50;\n   NSLog(@\"a = %i\", a);\n    } myBlock();\n     输出结果: 50\n```\n\n* 默认情况下, Block内部不能修改外面的局部变量\n\n```\nint b = 5;\n void (^myBlock)() = ^{\n  b = 20;\n// 报错 NSLog(@\"b = %i\", b);\n    };\n     myBlock();\n```\n\n* Block内部可以修改使用__block修饰的局部变量\n\n```\n__block int b = 5;\nvoid (^myBlock)() = ^{\n  b = 20;\n  NSLog(@\"b = %i\", b);\n  };\nmyBlock();\n输出结果: 20\n```\n\n* block中可以访问外面的变量\n\n* block中可以定义和外界同名的变量, 并且如果在block中定义了和外界同名的变量, 在block中访问的是block中的变量 \n* 默认情况下, 不可以在block中修改外界变量的值,因为block中的变量和外界的变量并不是同一个变量\n* 如果block中访问到了外界的变量, block会将外界的变量拷贝一份到堆内存中,因为block中使用的外界变量是copy的, 所以在调用之前修改外界变量的值, 不会影响到block中copy的值\n\n* 如果想在block中修改外界变量的值, 必须在外界变量前面加上__block ,那么会影响到外界变量的值\n\n* 如果没有添加__block是值传递\n* 如果加上__block之后就是地址传递, 所以可以在block中修改外界变量的值 \n\n\n#### 下面我们通过一个小案例来演示block的基本使用场景\n### block保存代码:\n案例:点击cell,作出相应的动作,在cell里面利用block保存代码\n* 1.在cell模型声明block属性\n\n```\n@property (nonatomic, strong) void(^block)();\n```\n* 2.在模型里面保存代码\n\n```    \n    // 打电话\n    CellItem *item = [CellItem cellItem];\n    item.title = @\"打电话\";\n    // 定义block给它\n    item.block = ^{\n        NSLog(@\"打电话\");\n    };\n```\n* 3.点击cell调用block\n\n```\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    CellItem *item = self.items[indexPath.row];\n   \n    if (item.block) {\n        item.block();\n    }\n}\n```\n### block传值\n开发中,block传值大致分为顺传和逆传\n> 顺传:比如A控制器把值传到Push之后的B控制器,就是顺传(定义属性)\n\n* 很简单,你一般只需要在在B控制器的头文件声明一个属性,A控制器拿到B控制器之后,把属性赋值,B控制器就可以拿到A传过来的值使用.\n\n>逆传:从名字就可以看出,是跟顺传反过来的,就是由B控制器反过来传回去A控制器,那么,这就没那么简单了\n\n* 逆传我们可以使用代理,但是开发中一般不会使用了,因为实在是比较麻烦,而且代码量很多,我们一般会使用block来代替代理,从而精简代码,看起来也比较容易理解\n\n先总结一下:`传值万能步骤:A传值B,A拿到B 就能传值  B传值A,拿到B就能传值`\n\n####利用block逆传\n* 1.在传递方头文件声明block属性\n\n```\n@property(nonatomic,strong)void(^block)(NSString*value);\n```\n* 2.在.m文件触发事件传值(参数)\n判断一下是否有block\n\n```\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    // 传值:\n    if (_block) {\n       _block(@\"123\");\n    }\n```\n* 3.接收方拿到传递方,拿到block接收值\n\n```\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    ModalViewController *modalVc = [[ModalViewController alloc] init];\n   \n    modalVc.block = ^(NSString *value){\n        NSLog(@\"利用了block,接收到值%@\",value);\n    };\n```\n\n```\n#好,上面简单介绍了block得传值方式,基本上开发的简单传值就是这么用的,一些复制的传值也是万变不离其宗\n```\n##block内存管理\n写在前面:为什么要理解或者掌握内存?!\n#######有一位大牛说过,你要灵活运用一个东西,就必须要知道它的内存是怎样运作,是怎么管理的,才能做到灵活运用到实际开发中\n\n>我们都知道,说到内存管理,可以分为ARC和MRC两种情况\n先来补充一下知识:\n如何判断当前项目是ARC,还是非ARC\n    1.在ARC中,不允许调用retain,release,retainCount\n    2.重写dealloc,ARC中不能调用[super dealloc]\n   \n   怎么进入非ARC环境 : 点击工程文件 -> buildSetting -> ARC\n  \n\n####1.ARC的block内存管理\nARC下,默认一个局部变量就是一个强指针,防止一创建就释放\nblock访问了一个局部变量,就会放到堆里面\n\n \t* 只要访问了一个外部变量,,生命周期不是全局的,只会放在堆里面\n   * 只要访问了一个外部变量,,生命周期是全局的,只会放在全局区\n\n只要在block代码块里面使用了self强引用就会导致循环引用\n\n\n\n```\n# 注意:只要在block的代码中,访问外部强指针对象,就会把对象强引用\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    int a = 2;\n   \n#注意:只要在block的代码中,访问外部强指针对象,就会把对象强引用\n#解决循环引用:将该对象使用weak或者block修饰符修饰之后再在block中使用/或者将其中一方强制制空 xxx = nil 。\n\n    __weak typeof(self) weakSelf = self;\n   \n    _block = ^{\n      \n        // 定义强指针的self\n        __strong typeof(self) strongSelf = weakSelf;\n       \n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n           \n            NSLog(@\"%@\",strongSelf);\n           \n        });\n       \n       \n        NSLog(@\"%d\",a);\n       \n    };\n   \n    _block(); \n}\n```\n_*从上面我们需要知道的是,什么是值传递,什么是指针传递*_\n* 值传递: 访问局部变量 \n* 指针传递:访问生命周期全局变量 \n* 而被__block修饰的局部变量,就是指针传递\n\n* 那么问题来了block是存储在堆中还是栈中?\n\n   //默认情况下block存储在栈中,如果对block进行一个copy操作, block会转移到堆中\n   //如果block在栈中, block中访问了外界的对象,那么不会对对象进行retain操作\n   //但是如果block在堆中, block中访问了外界的对象,那么会对外界的对象进行一次retain\n   \n   //如果在block中访问了外界的对象,一定要给对象加上__block,只要加上了__block,哪怕block在堆中,也不会对外界的对象进行retain\n   //如果是在ARC开发中就需要在前面加上__weak\n\n好,知道了上面的知识,你就会明白这一段代码的意思,为什么要加上这一句`__strong typeof(self) strongSelf = weakSelf;`\n我们的目的是:在要执行完那个延迟block,而且拿到对象`strongSelf`做完我们需要做的事情之后,modal出来的控制器才销毁\n如果没有一个强引用(上面那一行代码),那么,当控制器dismiss之后就释放掉那我们就拿不到`weakSelf`这个对象做事情了.\n###2.非ARC(MRC)的block内存管理\n\n只要block访问了外部变量,生命周期不是全局的(是否在代码块里面),就存放在栈里面 \n生命周期是全局的,block就存放在全局区 \n\n\nblock在非ARC中必须要使用copy  \n\n在非ARC环境下,retain相当于strong,为什么block不用retain \n因为在非arc中,是不会存放到堆里面,过了代码块就会被释放.再访问就会坏内存访问报错 \n\n在非ARC开发注意点:访问属性,一定要使用get,set方法,不能直接使用下划线\n\n\n\n####bock开发场景:参数使用 \n* 1.封装一个类的时候,有些时候,怎么去做由外界决定,但是由内部决定什么时候调用,把block当做一个参数去使用. \n\n* 2.动画block:做什么样的动画由我们决定,但是什么时候调用由系统决定. \n\n\n####bock开发场景:作为返回值使用\n这里就涉及到链式编程思想了,所谓的链式编程思想: 把所有的方法调用全部通过.语法连接起来,好处:可读性非常好\n\n```\nmgr.add(5).add(5); \n其实是分两步走,先调用mgr.add的getter,返回一个block.再跟着()实现这个block \n\n- (CalculatorManager *(^)(int))add; \n\n- (CalculatorManager *(^)(int))add\n{\n    return ^(int value){\n       \n        _result += value;\n       \n        return self;\n    }; \n}\n\n```\n\n##block在实际开发的应用举个例\n* 定义网络请求的类\n\n```\n@interface HttpTool : NSObject\n- (void)loadRequest:(void (^)())callBackBlock;\n@end\n\n@implementation HttpTool\n- (void)loadRequest:(void (^)())callBackBlock\n{\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        NSLog(@\"加载网络数据:%@\", [NSThread currentThread]);\n\n        dispatch_async(dispatch_get_main_queue(), ^{\n            callBackBlock();\n        });\n    });\n}\n@end\n```\n\n* 进行网络请求,请求到数据后利用block进行回调\n\n```\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [self.httpTool loadRequest:^{\n        NSLog(@\"主线程中,将数据回调.%@\", [NSThread currentThread]);\n    }];\n}\n``` \n\n###一些事:\n* 用strong还是copy的问题?\nblock 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.\n★建议:在ARC中,能用strong就用strong,因为copy内部会做很多事情\n\n* block是对象吗?\n是的!苹果告诉我的\\^0\\^!文档说的很清楚的\n\n\n```\n写在最后,block之强大可谓开发利器\n\t\t\t\t\t\t\t\t------make by LJW 转载请注明出处-------\n```\n\n\n\n\n\n\n","slug":"开发利器-Block","published":1,"updated":"2016-05-30T06:25:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciotn327700034qoj51mffc20","content":"<p>#Block</p>\n<p>##block写法</p>\n<ul>\n<li><a id=\"more\"></a>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">block的写法:</span><br><span class=\"line\">    类型:</span><br><span class=\"line\">    返回值(^block的名称)(block的参数)</span><br><span class=\"line\"></span><br><span class=\"line\">    值:</span><br><span class=\"line\">    ^(参数列表) &#123;</span><br><span class=\"line\">        // 执行的代码</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>##block基本使用</p>\n<ul>\n<li>作用就是用来保存一段代码块,在一个方法定义,在另外一个方法去调用(用的少,可以用定义方法替代,一般在 在一个类中定义,在另外一个类中去调用 用的比较多<br>###定义的几种方式</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#方式一: 等号 = ^(参数)&#123; block代码块 &#125;</span></span><br><span class=\"line\"> void(^block1)(int) = ^(int a)&#123;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">\"调用了block%d\"</span>,a);</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意点:如果block带有参数,在定义的时候,一定要有参数,并且变量名不能省略</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 方式二: 如果没有参数,参数可以省略</span><br><span class=\"line\">    void(^block2)() = ^&#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 方式三: 等会右边 = ^返回值(参数),返回值可以省略,不管有没有返回值,都可以省略</span><br><span class=\"line\">    int(^block3)() = ^int&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意:如果Block有返回值,block代码块必须要有返回值</li>\n</ul>\n<p>对于初学者,block的语法格式可能比较难记,可以尝试先用快捷的方式敲出格式,再根据生成的格式填入<br>    <code>block快捷方式:inline</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;#returnType#&gt;(^&lt;#blockName#&gt;)(&lt;#parameterTypes#&gt;) = ^(&lt;#parameters#&gt;) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        &lt;#statements#&gt;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">```\t</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">###block注意事项</span><br><span class=\"line\">* 在block内部可以访问block外部的变量</span><br></pre></td></tr></table></figure>\n<p>int a = 10;<br> void (^myBlock)() = ^{<br>  NSLog(@”a = %i”, a);<br>   } myBlock();<br>    输出结果: 10<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* block内部也可以定义和block外部的同名的变量(局部变量),此时局部变量会暂时屏蔽外部</span><br></pre></td></tr></table></figure></p>\n<p>int a = 10;<br> void (^myBlock)() = ^{<br>  int a = 50;<br>   NSLog(@”a = %i”, a);<br>    } myBlock();<br>     输出结果: 50<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 默认情况下, Block内部不能修改外面的局部变量</span><br></pre></td></tr></table></figure></p>\n<p>int b = 5;<br> void (^myBlock)() = ^{<br>  b = 20;<br>// 报错 NSLog(@”b = %i”, b);<br>    };<br>     myBlock();<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* Block内部可以修改使用__block修饰的局部变量</span><br></pre></td></tr></table></figure></p>\n<p>__block int b = 5;<br>void (^myBlock)() = ^{<br>  b = 20;<br>  NSLog(@”b = %i”, b);<br>  };<br>myBlock();<br>输出结果: 20<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* block中可以访问外面的变量</span><br><span class=\"line\"></span><br><span class=\"line\">* block中可以定义和外界同名的变量, 并且如果在block中定义了和外界同名的变量, 在block中访问的是block中的变量 </span><br><span class=\"line\">* 默认情况下, 不可以在block中修改外界变量的值,因为block中的变量和外界的变量并不是同一个变量</span><br><span class=\"line\">* 如果block中访问到了外界的变量, block会将外界的变量拷贝一份到堆内存中,因为block中使用的外界变量是copy的, 所以在调用之前修改外界变量的值, 不会影响到block中copy的值</span><br><span class=\"line\"></span><br><span class=\"line\">* 如果想在block中修改外界变量的值, 必须在外界变量前面加上__block ,那么会影响到外界变量的值</span><br><span class=\"line\"></span><br><span class=\"line\">* 如果没有添加__block是值传递</span><br><span class=\"line\">* 如果加上__block之后就是地址传递, 所以可以在block中修改外界变量的值 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### 下面我们通过一个小案例来演示block的基本使用场景</span><br><span class=\"line\">### block保存代码:</span><br><span class=\"line\">案例:点击cell,作出相应的动作,在cell里面利用block保存代码</span><br><span class=\"line\">* 1.在cell模型声明block属性</span><br></pre></td></tr></table></figure></p>\n<p>@property (nonatomic, strong) void(^block)();<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 2.在模型里面保存代码</span><br><span class=\"line\"></span><br><span class=\"line\">```    </span><br><span class=\"line\">    // 打电话</span><br><span class=\"line\">    CellItem *item = [CellItem cellItem];</span><br><span class=\"line\">    item.title = @&quot;打电话&quot;;</span><br><span class=\"line\">    // 定义block给它</span><br><span class=\"line\">    item.block = ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;打电话&quot;);</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>3.点击cell调用block</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    CellItem *item = self.items[indexPath.row];</span><br><span class=\"line\">   </span><br><span class=\"line\">    if (item.block) &#123;</span><br><span class=\"line\">        item.block();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"block传值\"><a href=\"#block传值\" class=\"headerlink\" title=\"block传值\"></a>block传值</h3><p>开发中,block传值大致分为顺传和逆传</p>\n<blockquote>\n<p>顺传:比如A控制器把值传到Push之后的B控制器,就是顺传(定义属性)</p>\n</blockquote>\n<ul>\n<li>很简单,你一般只需要在在B控制器的头文件声明一个属性,A控制器拿到B控制器之后,把属性赋值,B控制器就可以拿到A传过来的值使用.</li>\n</ul>\n<blockquote>\n<p>逆传:从名字就可以看出,是跟顺传反过来的,就是由B控制器反过来传回去A控制器,那么,这就没那么简单了</p>\n</blockquote>\n<ul>\n<li>逆传我们可以使用代理,但是开发中一般不会使用了,因为实在是比较麻烦,而且代码量很多,我们一般会使用block来代替代理,从而精简代码,看起来也比较容易理解</li>\n</ul>\n<p>先总结一下:<code>传值万能步骤:A传值B,A拿到B 就能传值  B传值A,拿到B就能传值</code></p>\n<p>####利用block逆传</p>\n<ul>\n<li>1.在传递方头文件声明block属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property(nonatomic,strong)void(^block)(NSString*value);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>2.在.m文件触发事件传值(参数)<br>判断一下是否有block</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 传值:</span><br><span class=\"line\">    if (_block) &#123;</span><br><span class=\"line\">       _block(@&quot;123&quot;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>3.接收方拿到传递方,拿到block接收值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ModalViewController *modalVc = [[ModalViewController alloc] init];</span><br><span class=\"line\">   </span><br><span class=\"line\">    modalVc.block = ^(NSString *value)&#123;</span><br><span class=\"line\">        NSLog(@&quot;利用了block,接收到值%@&quot;,value);</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#好,上面简单介绍了block得传值方式,基本上开发的简单传值就是这么用的,一些复制的传值也是万变不离其宗</span><br></pre></td></tr></table></figure>\n<p>##block内存管理<br>写在前面:为什么要理解或者掌握内存?!</p>\n<p>#######有一位大牛说过,你要灵活运用一个东西,就必须要知道它的内存是怎样运作,是怎么管理的,才能做到灵活运用到实际开发中</p>\n<blockquote>\n<p>我们都知道,说到内存管理,可以分为ARC和MRC两种情况<br>先来补充一下知识:<br>如何判断当前项目是ARC,还是非ARC<br>    1.在ARC中,不允许调用retain,release,retainCount<br>    2.重写dealloc,ARC中不能调用[super dealloc]</p>\n</blockquote>\n<p>   怎么进入非ARC环境 : 点击工程文件 -&gt; buildSetting -&gt; ARC</p>\n<p>####1.ARC的block内存管理<br>ARC下,默认一个局部变量就是一个强指针,防止一创建就释放<br>block访问了一个局部变量,就会放到堆里面</p>\n<pre><code>* 只要访问了一个外部变量,,生命周期不是全局的,只会放在堆里面\n</code></pre><ul>\n<li>只要访问了一个外部变量,,生命周期是全局的,只会放在全局区</li>\n</ul>\n<p>只要在block代码块里面使用了self强引用就会导致循环引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 注意:只要在block的代码中,访问外部强指针对象,就会把对象强引用</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    int a = 2;</span><br><span class=\"line\">   </span><br><span class=\"line\">#注意:只要在block的代码中,访问外部强指针对象,就会把对象强引用</span><br><span class=\"line\">#解决循环引用:将该对象使用weak或者block修饰符修饰之后再在block中使用/或者将其中一方强制制空 xxx = nil 。</span><br><span class=\"line\"></span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">   </span><br><span class=\"line\">    _block = ^&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">        // 定义强指针的self</span><br><span class=\"line\">        __strong typeof(self) strongSelf = weakSelf;</span><br><span class=\"line\">       </span><br><span class=\"line\">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">           </span><br><span class=\"line\">            NSLog(@&quot;%@&quot;,strongSelf);</span><br><span class=\"line\">           </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">       </span><br><span class=\"line\">       </span><br><span class=\"line\">        NSLog(@&quot;%d&quot;,a);</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">   </span><br><span class=\"line\">    _block(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em><em>从上面我们需要知道的是,什么是值传递,什么是指针传递</em></em></p>\n<ul>\n<li>值传递: 访问局部变量 </li>\n<li>指针传递:访问生命周期全局变量 </li>\n<li><p>而被__block修饰的局部变量,就是指针传递</p>\n</li>\n<li><p>那么问题来了block是存储在堆中还是栈中?</p>\n<p> //默认情况下block存储在栈中,如果对block进行一个copy操作, block会转移到堆中<br> //如果block在栈中, block中访问了外界的对象,那么不会对对象进行retain操作<br> //但是如果block在堆中, block中访问了外界的对象,那么会对外界的对象进行一次retain</p>\n<p> //如果在block中访问了外界的对象,一定要给对象加上<strong>block,只要加上了</strong>block,哪怕block在堆中,也不会对外界的对象进行retain<br> //如果是在ARC开发中就需要在前面加上__weak</p>\n</li>\n</ul>\n<p>好,知道了上面的知识,你就会明白这一段代码的意思,为什么要加上这一句<code>__strong typeof(self) strongSelf = weakSelf;</code><br>我们的目的是:在要执行完那个延迟block,而且拿到对象<code>strongSelf</code>做完我们需要做的事情之后,modal出来的控制器才销毁<br>如果没有一个强引用(上面那一行代码),那么,当控制器dismiss之后就释放掉那我们就拿不到<code>weakSelf</code>这个对象做事情了.</p>\n<p>###2.非ARC(MRC)的block内存管理</p>\n<p>只要block访问了外部变量,生命周期不是全局的(是否在代码块里面),就存放在栈里面<br>生命周期是全局的,block就存放在全局区 </p>\n<p>block在非ARC中必须要使用copy  </p>\n<p>在非ARC环境下,retain相当于strong,为什么block不用retain<br>因为在非arc中,是不会存放到堆里面,过了代码块就会被释放.再访问就会坏内存访问报错 </p>\n<p>在非ARC开发注意点:访问属性,一定要使用get,set方法,不能直接使用下划线</p>\n<p>####bock开发场景:参数使用 </p>\n<ul>\n<li><p>1.封装一个类的时候,有些时候,怎么去做由外界决定,但是由内部决定什么时候调用,把block当做一个参数去使用. </p>\n</li>\n<li><p>2.动画block:做什么样的动画由我们决定,但是什么时候调用由系统决定. </p>\n</li>\n</ul>\n<p>####bock开发场景:作为返回值使用<br>这里就涉及到链式编程思想了,所谓的链式编程思想: 把所有的方法调用全部通过.语法连接起来,好处:可读性非常好</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mgr.add(5).add(5); </span><br><span class=\"line\">其实是分两步走,先调用mgr.add的getter,返回一个block.再跟着()实现这个block </span><br><span class=\"line\"></span><br><span class=\"line\">- (CalculatorManager *(^)(int))add; </span><br><span class=\"line\"></span><br><span class=\"line\">- (CalculatorManager *(^)(int))add</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return ^(int value)&#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">        _result += value;</span><br><span class=\"line\">       </span><br><span class=\"line\">        return self;</span><br><span class=\"line\">    &#125;; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>##block在实际开发的应用举个例</p>\n<ul>\n<li>定义网络请求的类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface HttpTool : NSObject</span><br><span class=\"line\">- (void)loadRequest:(void (^)())callBackBlock;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation HttpTool</span><br><span class=\"line\">- (void)loadRequest:(void (^)())callBackBlock</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;加载网络数据:%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            callBackBlock();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<ul>\n<li>进行网络请求,请求到数据后利用block进行回调</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.httpTool loadRequest:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;主线程中,将数据回调.%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">###一些事:</span><br><span class=\"line\">* 用strong还是copy的问题?</span><br><span class=\"line\">block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.</span><br><span class=\"line\">★建议:在ARC中,能用strong就用strong,因为copy内部会做很多事情</span><br><span class=\"line\"></span><br><span class=\"line\">* block是对象吗?</span><br><span class=\"line\">是的!苹果告诉我的\\^0\\^!文档说的很清楚的</span><br></pre></td></tr></table></figure>\n<p>写在最后,block之强大可谓开发利器<br>                                ——make by LJW 转载请注明出处——-<br>```</p>\n","excerpt":"<p>#Block</p>\n<p>##block写法</p>\n<ul>\n<li>","more":"</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">block的写法:</span><br><span class=\"line\">    类型:</span><br><span class=\"line\">    返回值(^block的名称)(block的参数)</span><br><span class=\"line\"></span><br><span class=\"line\">    值:</span><br><span class=\"line\">    ^(参数列表) &#123;</span><br><span class=\"line\">        // 执行的代码</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>##block基本使用</p>\n<ul>\n<li>作用就是用来保存一段代码块,在一个方法定义,在另外一个方法去调用(用的少,可以用定义方法替代,一般在 在一个类中定义,在另外一个类中去调用 用的比较多<br>###定义的几种方式</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#方式一: 等号 = ^(参数)&#123; block代码块 &#125;</span></span><br><span class=\"line\"> void(^block1)(int) = ^(int a)&#123;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">\"调用了block%d\"</span>,a);</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意点:如果block带有参数,在定义的时候,一定要有参数,并且变量名不能省略</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 方式二: 如果没有参数,参数可以省略</span><br><span class=\"line\">    void(^block2)() = ^&#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 方式三: 等会右边 = ^返回值(参数),返回值可以省略,不管有没有返回值,都可以省略</span><br><span class=\"line\">    int(^block3)() = ^int&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意:如果Block有返回值,block代码块必须要有返回值</li>\n</ul>\n<p>对于初学者,block的语法格式可能比较难记,可以尝试先用快捷的方式敲出格式,再根据生成的格式填入<br>    <code>block快捷方式:inline</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;#returnType#&gt;(^&lt;#blockName#&gt;)(&lt;#parameterTypes#&gt;) = ^(&lt;#parameters#&gt;) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        &lt;#statements#&gt;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">```\t</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">###block注意事项</span><br><span class=\"line\">* 在block内部可以访问block外部的变量</span><br></pre></td></tr></table></figure>\n<p>int a = 10;<br> void (^myBlock)() = ^{<br>  NSLog(@”a = %i”, a);<br>   } myBlock();<br>    输出结果: 10<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* block内部也可以定义和block外部的同名的变量(局部变量),此时局部变量会暂时屏蔽外部</span><br></pre></td></tr></table></figure></p>\n<p>int a = 10;<br> void (^myBlock)() = ^{<br>  int a = 50;<br>   NSLog(@”a = %i”, a);<br>    } myBlock();<br>     输出结果: 50<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 默认情况下, Block内部不能修改外面的局部变量</span><br></pre></td></tr></table></figure></p>\n<p>int b = 5;<br> void (^myBlock)() = ^{<br>  b = 20;<br>// 报错 NSLog(@”b = %i”, b);<br>    };<br>     myBlock();<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* Block内部可以修改使用__block修饰的局部变量</span><br></pre></td></tr></table></figure></p>\n<p>__block int b = 5;<br>void (^myBlock)() = ^{<br>  b = 20;<br>  NSLog(@”b = %i”, b);<br>  };<br>myBlock();<br>输出结果: 20<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* block中可以访问外面的变量</span><br><span class=\"line\"></span><br><span class=\"line\">* block中可以定义和外界同名的变量, 并且如果在block中定义了和外界同名的变量, 在block中访问的是block中的变量 </span><br><span class=\"line\">* 默认情况下, 不可以在block中修改外界变量的值,因为block中的变量和外界的变量并不是同一个变量</span><br><span class=\"line\">* 如果block中访问到了外界的变量, block会将外界的变量拷贝一份到堆内存中,因为block中使用的外界变量是copy的, 所以在调用之前修改外界变量的值, 不会影响到block中copy的值</span><br><span class=\"line\"></span><br><span class=\"line\">* 如果想在block中修改外界变量的值, 必须在外界变量前面加上__block ,那么会影响到外界变量的值</span><br><span class=\"line\"></span><br><span class=\"line\">* 如果没有添加__block是值传递</span><br><span class=\"line\">* 如果加上__block之后就是地址传递, 所以可以在block中修改外界变量的值 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### 下面我们通过一个小案例来演示block的基本使用场景</span><br><span class=\"line\">### block保存代码:</span><br><span class=\"line\">案例:点击cell,作出相应的动作,在cell里面利用block保存代码</span><br><span class=\"line\">* 1.在cell模型声明block属性</span><br></pre></td></tr></table></figure></p>\n<p>@property (nonatomic, strong) void(^block)();<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 2.在模型里面保存代码</span><br><span class=\"line\"></span><br><span class=\"line\">```    </span><br><span class=\"line\">    // 打电话</span><br><span class=\"line\">    CellItem *item = [CellItem cellItem];</span><br><span class=\"line\">    item.title = @&quot;打电话&quot;;</span><br><span class=\"line\">    // 定义block给它</span><br><span class=\"line\">    item.block = ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;打电话&quot;);</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>3.点击cell调用block</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    CellItem *item = self.items[indexPath.row];</span><br><span class=\"line\">   </span><br><span class=\"line\">    if (item.block) &#123;</span><br><span class=\"line\">        item.block();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"block传值\"><a href=\"#block传值\" class=\"headerlink\" title=\"block传值\"></a>block传值</h3><p>开发中,block传值大致分为顺传和逆传</p>\n<blockquote>\n<p>顺传:比如A控制器把值传到Push之后的B控制器,就是顺传(定义属性)</p>\n</blockquote>\n<ul>\n<li>很简单,你一般只需要在在B控制器的头文件声明一个属性,A控制器拿到B控制器之后,把属性赋值,B控制器就可以拿到A传过来的值使用.</li>\n</ul>\n<blockquote>\n<p>逆传:从名字就可以看出,是跟顺传反过来的,就是由B控制器反过来传回去A控制器,那么,这就没那么简单了</p>\n</blockquote>\n<ul>\n<li>逆传我们可以使用代理,但是开发中一般不会使用了,因为实在是比较麻烦,而且代码量很多,我们一般会使用block来代替代理,从而精简代码,看起来也比较容易理解</li>\n</ul>\n<p>先总结一下:<code>传值万能步骤:A传值B,A拿到B 就能传值  B传值A,拿到B就能传值</code></p>\n<p>####利用block逆传</p>\n<ul>\n<li>1.在传递方头文件声明block属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property(nonatomic,strong)void(^block)(NSString*value);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>2.在.m文件触发事件传值(参数)<br>判断一下是否有block</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 传值:</span><br><span class=\"line\">    if (_block) &#123;</span><br><span class=\"line\">       _block(@&quot;123&quot;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>3.接收方拿到传递方,拿到block接收值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ModalViewController *modalVc = [[ModalViewController alloc] init];</span><br><span class=\"line\">   </span><br><span class=\"line\">    modalVc.block = ^(NSString *value)&#123;</span><br><span class=\"line\">        NSLog(@&quot;利用了block,接收到值%@&quot;,value);</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#好,上面简单介绍了block得传值方式,基本上开发的简单传值就是这么用的,一些复制的传值也是万变不离其宗</span><br></pre></td></tr></table></figure>\n<p>##block内存管理<br>写在前面:为什么要理解或者掌握内存?!</p>\n<p>#######有一位大牛说过,你要灵活运用一个东西,就必须要知道它的内存是怎样运作,是怎么管理的,才能做到灵活运用到实际开发中</p>\n<blockquote>\n<p>我们都知道,说到内存管理,可以分为ARC和MRC两种情况<br>先来补充一下知识:<br>如何判断当前项目是ARC,还是非ARC<br>    1.在ARC中,不允许调用retain,release,retainCount<br>    2.重写dealloc,ARC中不能调用[super dealloc]</p>\n</blockquote>\n<p>   怎么进入非ARC环境 : 点击工程文件 -&gt; buildSetting -&gt; ARC</p>\n<p>####1.ARC的block内存管理<br>ARC下,默认一个局部变量就是一个强指针,防止一创建就释放<br>block访问了一个局部变量,就会放到堆里面</p>\n<pre><code>* 只要访问了一个外部变量,,生命周期不是全局的,只会放在堆里面\n</code></pre><ul>\n<li>只要访问了一个外部变量,,生命周期是全局的,只会放在全局区</li>\n</ul>\n<p>只要在block代码块里面使用了self强引用就会导致循环引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 注意:只要在block的代码中,访问外部强指针对象,就会把对象强引用</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    int a = 2;</span><br><span class=\"line\">   </span><br><span class=\"line\">#注意:只要在block的代码中,访问外部强指针对象,就会把对象强引用</span><br><span class=\"line\">#解决循环引用:将该对象使用weak或者block修饰符修饰之后再在block中使用/或者将其中一方强制制空 xxx = nil 。</span><br><span class=\"line\"></span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">   </span><br><span class=\"line\">    _block = ^&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">        // 定义强指针的self</span><br><span class=\"line\">        __strong typeof(self) strongSelf = weakSelf;</span><br><span class=\"line\">       </span><br><span class=\"line\">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">           </span><br><span class=\"line\">            NSLog(@&quot;%@&quot;,strongSelf);</span><br><span class=\"line\">           </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">       </span><br><span class=\"line\">       </span><br><span class=\"line\">        NSLog(@&quot;%d&quot;,a);</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">   </span><br><span class=\"line\">    _block(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em><em>从上面我们需要知道的是,什么是值传递,什么是指针传递</em></em></p>\n<ul>\n<li>值传递: 访问局部变量 </li>\n<li>指针传递:访问生命周期全局变量 </li>\n<li><p>而被__block修饰的局部变量,就是指针传递</p>\n</li>\n<li><p>那么问题来了block是存储在堆中还是栈中?</p>\n<p> //默认情况下block存储在栈中,如果对block进行一个copy操作, block会转移到堆中<br> //如果block在栈中, block中访问了外界的对象,那么不会对对象进行retain操作<br> //但是如果block在堆中, block中访问了外界的对象,那么会对外界的对象进行一次retain</p>\n<p> //如果在block中访问了外界的对象,一定要给对象加上<strong>block,只要加上了</strong>block,哪怕block在堆中,也不会对外界的对象进行retain<br> //如果是在ARC开发中就需要在前面加上__weak</p>\n</li>\n</ul>\n<p>好,知道了上面的知识,你就会明白这一段代码的意思,为什么要加上这一句<code>__strong typeof(self) strongSelf = weakSelf;</code><br>我们的目的是:在要执行完那个延迟block,而且拿到对象<code>strongSelf</code>做完我们需要做的事情之后,modal出来的控制器才销毁<br>如果没有一个强引用(上面那一行代码),那么,当控制器dismiss之后就释放掉那我们就拿不到<code>weakSelf</code>这个对象做事情了.</p>\n<p>###2.非ARC(MRC)的block内存管理</p>\n<p>只要block访问了外部变量,生命周期不是全局的(是否在代码块里面),就存放在栈里面<br>生命周期是全局的,block就存放在全局区 </p>\n<p>block在非ARC中必须要使用copy  </p>\n<p>在非ARC环境下,retain相当于strong,为什么block不用retain<br>因为在非arc中,是不会存放到堆里面,过了代码块就会被释放.再访问就会坏内存访问报错 </p>\n<p>在非ARC开发注意点:访问属性,一定要使用get,set方法,不能直接使用下划线</p>\n<p>####bock开发场景:参数使用 </p>\n<ul>\n<li><p>1.封装一个类的时候,有些时候,怎么去做由外界决定,但是由内部决定什么时候调用,把block当做一个参数去使用. </p>\n</li>\n<li><p>2.动画block:做什么样的动画由我们决定,但是什么时候调用由系统决定. </p>\n</li>\n</ul>\n<p>####bock开发场景:作为返回值使用<br>这里就涉及到链式编程思想了,所谓的链式编程思想: 把所有的方法调用全部通过.语法连接起来,好处:可读性非常好</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mgr.add(5).add(5); </span><br><span class=\"line\">其实是分两步走,先调用mgr.add的getter,返回一个block.再跟着()实现这个block </span><br><span class=\"line\"></span><br><span class=\"line\">- (CalculatorManager *(^)(int))add; </span><br><span class=\"line\"></span><br><span class=\"line\">- (CalculatorManager *(^)(int))add</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return ^(int value)&#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">        _result += value;</span><br><span class=\"line\">       </span><br><span class=\"line\">        return self;</span><br><span class=\"line\">    &#125;; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>##block在实际开发的应用举个例</p>\n<ul>\n<li>定义网络请求的类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface HttpTool : NSObject</span><br><span class=\"line\">- (void)loadRequest:(void (^)())callBackBlock;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation HttpTool</span><br><span class=\"line\">- (void)loadRequest:(void (^)())callBackBlock</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;加载网络数据:%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            callBackBlock();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<ul>\n<li>进行网络请求,请求到数据后利用block进行回调</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.httpTool loadRequest:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;主线程中,将数据回调.%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">###一些事:</span><br><span class=\"line\">* 用strong还是copy的问题?</span><br><span class=\"line\">block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.</span><br><span class=\"line\">★建议:在ARC中,能用strong就用strong,因为copy内部会做很多事情</span><br><span class=\"line\"></span><br><span class=\"line\">* block是对象吗?</span><br><span class=\"line\">是的!苹果告诉我的\\^0\\^!文档说的很清楚的</span><br></pre></td></tr></table></figure>\n<p>写在最后,block之强大可谓开发利器<br>                                ——make by LJW 转载请注明出处——-<br>```</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}